# -*- coding: utf-8 -*-
"""Exams1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s-XaJqV8TqORbeoKB9ac-HbIQ7YRmCWL
"""

try:
    import firedrake
except ImportError:
    !wget "https://fem-on-colab.github.io/releases/firedrake-install-real.sh" -O "/tmp/firedrake-install.sh" && bash "/tmp/firedrake-install.sh"
    import firedrake

from firedrake import *
#import firedrake as fd
import numpy as np
import finat
import firedrake.pyplot as fdplt
import matplotlib.pyplot as plt
from firedrake.__future__ import interpolate

"""# TDE 1 21/06/2023
-  Exercise 1: ELLIPTIC 2D, NEUMANN AND DIRICHLET HOMOGENEOUS, SIMPY
- Exercise 2: STOKES SYSTEM RESOLUTION, DIRICHLET NON HOMOGENEOUS (FUNCTION)

## Exercise 1: ELLIPTIC 2D, NEUMANN AND DIRICHLET HOMOGENEOUS, SIMPY
"""

# POINT 2
import numpy as np
from sympy import * # Symbolic computations

x, y = symbols('x y')
u_ex = y*(1-y)*cos((pi*x)/2)
dudx = diff(u_ex, x)
dudy = diff(u_ex, y)
d2udx2 = diff(dudx, x)
d2udy2 = diff(dudy, y)
laplacian_u = d2udx2+d2udy2
grad_u = (dudx,dudy)

f = -laplacian_u
print(f)

# THE NEUMAN CONDITION HOLDS F0R x = 0, THE LEFT EDGE, SO THE NORMAL VEXOR N
n = (-1,0)
g_n = grad_u[0] * n[0] + grad_u[1] * n[1]
g_n=g_n.subs({x: 0, y: y})
print(g_n)
# THE DIRICHLET CONDITION MUST HOLD FOR THE OTHER EDGES SO
u_bound1 = u_ex.subs({x: x, y: 0})
print(u_bound1)
u_bound2 = u_ex.subs({x: 1, y: y})
print(u_bound2)
u_bound3 = u_ex.subs({x: x, y: 1})
print(u_bound3)

"""Point 3"""

N = 10
mesh = fd.UnitSquareMesh(N, N)
V = fd.FunctionSpace(mesh, 'P', 1)
x = fd.SpatialCoordinate(mesh)
fig, ax = plt.subplots()
fdplt.triplot(mesh, axes=ax)
ax.legend()

def solver2D(N, parameters):

  # DISCRETIZATION
  mesh = fd.UnitSquareMesh(N, N)
  V = fd.FunctionSpace(mesh, 'P', 1)
  x = fd.SpatialCoordinate(mesh)

  # DIRICHLET BCS
  bc = fd.DirichletBC(V, fd.Constant(0.0), (2, 3, 4))

  # VARIATIONAL FORMULATION
  u = fd.TrialFunction(V)
  v = fd.TestFunction(V)

  gN = fd.Constant(0.0)

  # FORCING TERM
  f = fd.pi**2*x[1]*(1 - x[1])*fd.cos(fd.pi*x[0]/2)/4 + 2*fd.cos(fd.pi*x[0]/2)

  # VARIATIONAL FORMULATION
  a = fd.dot(fd.grad(u), fd.grad(v)) * dx
  L = f*v*dx + gN*v*ds(1)

  u_h = fd.Function(V)
  vpb = fd.LinearVariationalProblem(a, L, u_h, bc)
  solver =  fd.LinearVariationalSolver(vpb, solver_parameters=parameters)
  solver.solve()

  u_ex_fd = x[1]*(1-x[1])*fd.cos((fd.pi*x[0])/2)
  H1error = fd.errornorm(u_ex_fd, u_h, norm_type='H1')
  L2error = fd.errornorm(u_ex_fd, u_h, norm_type='L2')

  return mesh, u_h, H1error, L2error

# Compare the performances in terms of iterations and time
# by using no preconditioner ('none'), or amg ('gamg')
# iterative methods: 'cg' or 'gmres'
N = 10

parameters = {'ksp_type': 'gmres', 'pc_type': 'ilu'} # Default setting
mesh, u_h, H1error, L2error = solver2D(N, parameters)

# PLOT SOLUTION
fig, ax = plt.subplots() # being 1 the free stream temperature
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q)

# PLOT ERROR
x = fd.SpatialCoordinate(mesh)
u_ex = x[1]*(1-x[1])*fd.cos((fd.pi*x[0])/2)
Vaux = fd.FunctionSpace(mesh, 'Lagrange', 3) # SHOULD BE HIGHER ORDER SPACE

fig, ax = plt.subplots()
q = fdplt.tripcolor(project(u_ex - u_h, Vaux), axes=ax)
fig.colorbar(q)

errvecH1 = []
errvecL2 = []
parameters = {'ksp_type': 'cg', 'pc_type': 'gamg'}
Nvec = np.array([10, 100, 500])
for N in Nvec:
  mesh, u_h, H1error, L2error = solver2D(N, parameters) # SOLVING FUNCTION
  errvecH1.append(H1error)
  errvecL2.append(L2error)

# Estimate the order of convergence
p_H1 = (np.log(errvecH1[0]) - np.log(errvecH1[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
print('Order of convergence in H1 norm = ', p_H1)
print('Order of convergence in L2 norm = ', p_L2)
# The solution is in H1 but not in H2, thus the convergence rate

fig, ax = plt.subplots()
ax.loglog(Nvec, errvecH1, 'x') # CONVERGENCE OF ORDER 1
ax.loglog(Nvec, 1/Nvec,color='r', label='Order 1')
ax.loglog(Nvec, errvecL2, 'o') # CONVERGENCE OF ORDER 2
ax.loglog(Nvec, 1/Nvec**2,color='b', label='Order 2')
ax.legend()

"""## Exercise 2: STOKES SYSTEM RESOLUTION, DIRICHLET NON HOMOGENEOUS (FUNCTION)"""

n = 10
mesh = UnitSquareMesh(n, n)

fig, ax = plt.subplots()
fdplt.triplot(mesh, axes=ax)
ax.legend()

# H1 VELOCITY L2 PRESURE WITH P2 P1
def solve_stokes(n, degreeU, degreeP, f_fun, delta, epsilon):
    # Mesh definition
    mesh = UnitSquareMesh(n, n)

    V = VectorFunctionSpace(mesh, 'P', degreeU)
    if degreeP==0:
        Q = FunctionSpace(mesh, 'DP', 0) #P0 element
    else:
        Q = FunctionSpace(mesh, 'P', degreeP)

    W = MixedFunctionSpace([V, Q])
    x = SpatialCoordinate(mesh)

    f = f_fun(x)
    #gN = lambda x: as_vector((x[1]-(x[1]**2), Constant(0.)))
    gN = ((x[1]-(x[1]**2), Constant(0.)))
    #g_N = gN(x)
    bc0 = DirichletBC(W.sub(0), Constant((0., 0.)), (3,4))
    bc1 = DirichletBC(W.sub(0), gN, (1,2))

    # Handle the pressure indetermination by specifying the nullspace
    # see https://www.firedrakeproject.org/solving-interface.html#singular-operators-in-mixed-spaces
    # According to the documentation, we provide a basis for the nullspace of pressure
    # For velocity, we pass the whole space, signifying that "we don't care about" it
    nullspace = MixedVectorSpaceBasis(
        W, [W.sub(0), VectorSpaceBasis(constant=True)]
    )

    # Variational formulation
    u, p = TrialFunctions(W)
    v, q = TestFunctions(W)

    a = inner(grad(u), grad(v)) * dx - div(v) * p * dx - q * div(u) * dx
    L = dot(f, v) * dx

    # Brezzi-Pitkaranta stabilization
    h = CellDiameter(mesh)
    a_stab = Constant(delta) * h * h * dot(grad(p), grad(q)) * dx
    #a -= a_stab

    # Pressure Stabilization
    a_pressure = Constant(epsilon) * dot(grad(p), grad(q)) * dx
    #a -= a_pressure

    # Penalty Stabilization
    a_penalty = Constant(epsilon) * p * q * dx
    #a += a_penalty

    # Solution
    w = Function(W)
    solve(a==L, w, (bc0, bc1), nullspace=nullspace)
    #solve(a == L, w, bcs=bc, nullspace=nullspace)
    uh, ph = w.subfunctions

    #pmean = assemble(ph*dx) # ACTIVATE WHEN STABILIZING FOR CONVERGENCE OF ORDER 1
    #ph -= pmean

    return uh, ph, mesh

h = 0.05
#h = 0.025
#h = 0.0125
n = int(1/h)

f_fun = lambda x: as_vector(([Constant(0.),Constant(0.)]))

uh, ph, mesh = solve_stokes(n, 2, 1, f_fun,1.,0.0001) # P2/P1 elements

fig, ax = plt.subplots(2, 1) # grid of 2 rows 1 colums
quiver(uh, axes=ax[0])
tripcolor(ph, axes=ax[1])
ax[0].set_aspect('equal')
ax[1].set_aspect('equal')

"""# TDE 2 07/07/2023
- Exercise 1: ELLIPTIC 2D, NON HOMOGENEOUS DIRICHLET
- Exercise 2: ADVECTION DIFFUSION REACTION, ARTIFICIAL VISCOSITY, SUPG

## Exercise 1: ELLIPTIC 2D, NON HOMOGENEOUS DIRICHLET
"""

Â§def solver2D(N):

  # DISCRETIZATION
  mesh = UnitSquareMesh(N, N, diagonal='left') # (N, N, diagonal='left' or 'right')
  V = FunctionSpace(mesh, 'P', 1)
  x = SpatialCoordinate(mesh) # Needed later

  # DIRICHLET BCS
  bc = DirichletBC(V, exp(x[0]+x[1]), "on_boundary")

  # VARIATIONAL FORMULATION
  u = TrialFunction(V)
  v = TestFunction(V)

  # FORCING TERM
  f = 2*exp(x[0]+x[1]) # FIREDRAKE OBJECT

  a = dot(grad(u), grad(v)) * dx
  L = -f*v*dx

  # SOLUTION - COMPUTING TIME
  u_h = Function(V)
  solve(a==L, u_h, bcs=bc)

  u_ex_fd = exp(x[0]+x[1])
  H1error = errornorm(u_ex_fd, u_h, norm_type='H1')
  L2error = errornorm(u_ex_fd, u_h, norm_type='L2')

  return u_h, mesh, H1error, L2error

# Compare the performances in terms of iterations and time
# by using no preconditioner ('none'), or amg ('gamg')
# iterative methods: 'cg' or 'gmres'
N = 10
u_h, mesh, H1error, L2error = solver2D(N)

# PLOT SOLUTION
fig, ax = plt.subplots() # being 1 the free stream temperature
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q)

# PLOT ERROR
x = SpatialCoordinate(mesh)
u_ex = exp(x[0]+x[1])
Vaux = FunctionSpace(mesh, 'Lagrange', 3) # SHOULD BE HIGHER ORDER SPACE

fig, ax = plt.subplots()
q = fdplt.tripcolor(project(u_ex - u_h, Vaux), axes=ax)
fig.colorbar(q)

errvecH1 = []
errvecL2 = []

Nvec = np.array([10, 50, 100])
for N in Nvec:
  u_h, mesh, H1error, L2error = solver2D(N) # SOLVING FUNCTION
  errvecH1.append(H1error)
  errvecL2.append(L2error)

# Estimate the order of convergence
p_H1 = (np.log(errvecH1[0]) - np.log(errvecH1[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
p_L2 = (np.log(errvecL2[0]) - np.log(errvecL2[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
print('Order of convergence in H1 norm = ', p_H1)
print('Order of convergence in L2 norm = ', p_L2)
# The solution is in H1 but not in H2, thus the convergence rate

fig, ax = plt.subplots()
ax.loglog(Nvec, errvecH1, 'x') # CONVERGENCE OF ORDER 1
ax.loglog(Nvec, 1/Nvec,color='r', label='Order 1')
ax.loglog(Nvec, errvecL2, 'o') # CONVERGENCE OF ORDER 2
ax.loglog(Nvec, 1/Nvec**2,color='b', label='Order 2')
ax.legend()

"""## EXERCISE 2: ADVECTION DIFFUSION REACTION, ARTIFICIAL VISCOSITY, SUPG"""

N=10
mesh = UnitSquareMesh(N, N, diagonal='left') # (N, N, diagonal='left' or 'right')
V = FunctionSpace(mesh, 'P', 1)
x = SpatialCoordinate(mesh) # Needed later
fig, ax = plt.subplots()     # to recognize every part of the boundary
fdplt.triplot(mesh, axes=ax) # 1, 2 -> Dirichlet boundary 3 -> Neumann boundary
ax.legend()                  # 4 -> Robin boundary

def solve_ADR(n, degree, delta, rho):

  # 1. mesh generation
  mesh = UnitSquareMesh(n, n, 'crossed')

  # 2. definition of finite element space
  V = FunctionSpace(mesh, 'P', degree)
  x = SpatialCoordinate(mesh)

  # BCS Dirichlet
  bc0 = DirichletBC(V, Constant(1.), (1,3)) # DIRICHLET ON 1 and 2 boundary
  bc1 = DirichletBC(V, Constant(0.), (2,4)) # DIRICHLET ON 1 and 2 boundary

  # 3. assembling bilinear form and linear functionals
  u = TrialFunction(V)
  v = TestFunction(V)

  # Physical Parameters
  b = as_vector([1000, 1000])
  mu = Constant(1.)
  f = Constant(0.)

  # Computing Peckle Number for Stabilization term
  h = CellDiameter(mesh)
  bnorm = sqrt(dot(b, b))
  Pe = bnorm*h/(2*mu)

  # ARTIFICIAL VISCOSITY DISCRETIZATION
  B_Pe = conditional(Pe>0, Pe/(exp(Pe)-1), 1)
  Phi_Pe = Pe - 1 + B_Pe
  mu_h = mu*(1+Phi_Pe)

  # VARIATIONAL FORMULATIONS
  # a = (mu_h * dot(grad(u), grad(v)) + dot(b, grad(u)) * v + u*v) * dx
  a = (mu * dot(grad(u), grad(v)) + dot(b, grad(u)) * v + u*v) * dx
  L = f * v * dx

  # STRONGLY CONSISTENT METHODS: SUPG and GLS, PART 1
  # THIS IS THE SUM OF THE INTEGRALS ON THE ELEMENTS, NOT AN INTEGRAL ON THE ENTIRE
  # DOMAIN, THERE ARE JUMPS IN THE GRADIENTS BETWEEN TWO ELEMENTS
  tau = 0.5*delta*h/bnorm * conditional(Pe/3 > 1, 1, Pe/3)
  R = lambda uu: -mu * div(grad(uu)) + dot(b, grad(uu))
  P = lambda uu: rho *(-mu * div(grad(uu))) + dot(b, grad(uu))
  c_strong = tau * R(u) * P(v) * dx # FIRST STABILIZATION TERM LHS
  a_stab = a + c_strong
  # STRONGLY CONSISTENT METHODS: SUPG and GLS, PART 2, ONLY FOR NON HOMOGENEOUS PROBLEMS
  d_strong = f * P(v) * dx # SECOND STABILIZATION RHS
  L_stab = L + d_strong

  # 4. solving discrete problem
  u_h = Function(V)
  solve(a==L, u_h, (bc0, bc1))
  #solve(a_stab == L, u_h, (bc0, bc1)) # STABILIZED HOMOGENEOUS
  #solve(a_stab == L_stab, u_h, (bc0, bc1)) # STABILIZED NON HOMOGENEOUS
  # solve(a == L, u_h, bc) # NOT STABILIZED

  return u_h, mesh

n = 100
degree = 1
delta = 1
rho = 1
u_h, mesh = solve_ADR(n, degree, delta, rho)

# PLOT SOLUTION
fig, ax = plt.subplots() # being 1 the free stream temperature
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q)

"""# TDE 3 04/09/2023
- Exercise 1: ELLIPTIC 2D, ASSEMBLE ENERGY FUNCTIONAL
- Exercise 2: STOKE SYSTEM, NON HOMOGENEOUS, VELOCITY CONVERGENCE (Code also for pressure), SIMPY

## Exercise 1: ELLIPTIC 2D, ASSEMBLE ENERGY FUNCTIONAL
"""

def solver2D_U(N):

  # DISCRETIZATION
  mesh = UnitSquareMesh(N, N)
  V = FunctionSpace(mesh, 'P', 1)
  x = SpatialCoordinate(mesh) # Needed later

  # DIRICHLET BCS
  gD = Constant(0.)
  bc = DirichletBC(V, gD, "on_boundary")

  # PROBLEM DATA
  f = Constant(1.)
  #mu = Constant(1.)
  mu = 1 + 5*x[1]

  # VARIATIONAL FORMULATION
  u = TrialFunction(V)
  v = TestFunction(V)

  # PROBLEM 1
  a = (mu * dot(grad(u), grad(v))) * dx
  L = f*v*dx

  # SOLUTION 1
  u_h = Function(V)
  solve(a==L, u_h, (bc))

  A = assemble(Constant(0.5)*dot(grad(u_h), grad(u_h))*dx - f*u_h*dx) # ENERGY FUNCTIONAL
  print('Energy U',A)

  return u_h, mesh

def solver2D_W(N):

  # DISCRETIZATION
  mesh = UnitSquareMesh(N, N)
  V = FunctionSpace(mesh, 'P', 1)
  x = SpatialCoordinate(mesh) # Needed later

  # DIRICHLET BCS
  gD = Constant(0.)
  bc = DirichletBC(V, gD, "on_boundary")

  # PROBLEM DATA
  f = Constant(1.)
  mu = Constant(1.)

  # VARIATIONAL FORMULATION
  u = TrialFunction(V)
  v = TestFunction(V)

  # PROBLEM
  a = (mu * dot(grad(u), grad(v))) * dx
  L = f*v*dx

  # SOLUTION
  w_h = Function(V)
  solve(a==L, w_h, (bc))

  A = assemble(Constant(0.5)*dot(grad(w_h), grad(w_h))*dx - f*w_h*dx) # ENERGY FUNCTIONAL
  print('Energy W',A)

  return w_h, mesh

N = 10
u_h, mesh_u = solver2D_U(N)
w_h, mesh_w = solver2D_W(N)

# PLOT SOLUTION
fig, ax = plt.subplots()
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q)

# PLOT SOLUTION
fig, ax = plt.subplots()
q = fdplt.tripcolor(w_h, axes=ax)
plt.colorbar(q)

"""## Exercise 2: STOKE SYSTEM, NON HOMOGENEOUS, VELOCITY CONVERGENCE (Code also for pressure), SIMPY"""

import numpy as np
from sympy import * # Symbolic computations

x, y, nu = symbols('x y nu')
u_ex = [x**2 + y**2, -2*x*y]

# GIVEN A VECTOR FIELD I CAN COMPUTE THE DIVERGENCE -> SCALAR
# DIVERGENCE = u_x/x + u_y/y
div_u = diff(u_ex[0], x) + diff(u_ex[1], y)
print('Divergence of u:',div_u)

# GIVEN A VECTOR FIELD I CAN COMPUTE THE LAPLACIAN -> [laplacian u_x,laplacian u_y]
laplacian_u_x = diff(u_ex[0], x, x) + diff(u_ex[0], y, y)
laplacian_u_y = diff(u_ex[1], x, x) + diff(u_ex[1], y, y)
laplacian_u = [laplacian_u_x, laplacian_u_y]
print('Laplacian of u:',laplacian_u)

# H1 VELOCITY L2 PRESURE WITH P2 P1
def solve_stokes(n, degreeU, degreeP, gD_fun, f_fun, delta, epsilon):
    # Mesh definition
    mesh = UnitSquareMesh(n, n)

    V = VectorFunctionSpace(mesh, 'P', degreeU)
    if degreeP==0:
        Q = FunctionSpace(mesh, 'DP', 0) #P0 element
    else:
        Q = FunctionSpace(mesh, 'P', degreeP)

    W = MixedFunctionSpace([V, Q])

    x = SpatialCoordinate(mesh)
    gD = gD_fun(x)
    f = f_fun(x)

    bc = DirichletBC(W.sub(0), gD, 'on_boundary')

    # Handle the pressure indetermination by specifying the nullspace
    # see https://www.firedrakeproject.org/solving-interface.html#singular-operators-in-mixed-spaces
    # According to the documentation, we provide a basis for the nullspace of pressure
    # For velocity, we pass the whole space, signifying that "we don't care about" it
    nullspace = MixedVectorSpaceBasis(
        W, [W.sub(0), VectorSpaceBasis(constant=True)]
    )

    # Variational formulation
    u, p = TrialFunctions(W)
    v, q = TestFunctions(W)

    a = inner(grad(u), grad(v)) * dx - div(v) * p * dx - q * div(u) * dx
    L = dot(f, v) * dx

    # Brezzi-Pitkaranta stabilization
    h = CellDiameter(mesh)
    a_stab = Constant(delta) * h * h * dot(grad(p), grad(q)) * dx
    a -= a_stab

    # Pressure Stabilization
    a_pressure = Constant(epsilon) * dot(grad(p), grad(q)) * dx
    #a -= a_pressure

    # Penalty Stabilization
    # EPSILON RANGE 0.01-0.0001 NOT BIGGER!
    a_penalty = Constant(epsilon) * p * q * dx
    #a += a_penalty

    # Solution
    w = Function(W)
    solve(a == L, w, bcs=bc, nullspace=nullspace)
    uh, ph = w.subfunctions

    pmean = assemble(ph*dx)
    ph -= pmean

    #u_ex_fun = lambda x: as_vector((-cos(x[0]) * sin(x[1]), sin(x[0]) * cos(x[1])))
    u_ex_fun = lambda x: as_vector((x[0]**2+x[1]**2,-2*x[0]*x[1]))
    p_ex_fun = lambda x: 4*x[0] - (x[1]**2)/2 + 1/6 -2
    u_ex = u_ex_fun(x)
    #p_ex = p_ex_fun(x)

    u_errH1 = errornorm(u_ex, uh, 'H1')
    u_errL2 = errornorm(u_ex, uh, 'L2')

    #p_errH1 = errornorm(p_ex, ph, 'H1')
    #p_errL2 = errornorm(p_ex, ph, 'L2')

    errH1 = u_errH1 #+ p_errH1
    errL2 = u_errL2 #+ p_errL2

    return uh, ph, mesh, errH1, errL2

u_ex_fun = lambda x: as_vector(((x[0]**2)+(x[1]**2),-2*x[0]*x[1]))
#p_ex_fun = lambda x: 4*x[0] - (x[1]**2)/2 + 1/6
# The last term in p_ex_fun makes sure that the mean is zero, consistent with the definition of the nullspace
f_fun = lambda x: as_vector((0.,-x[1]))
#u_ex_fun = lambda x: as_vector((-cos(x[0]) * sin(x[1]), sin(x[0]) * cos(x[1])))
# The last term in p_ex_fun makes sure that the mean is zero, consistent with the definition of the nullspace
#p_ex_fun = lambda x: -0.25 * (cos(2*x[0]) + cos(2*x[1])) + 0.25*sin(2)
#f_fun = lambda x: as_vector((-2 * cos(x[0]) * sin(x[1]) + 0.5 * sin(2 * x[0]),
                  # 2 * sin(x[0]) * cos(x[1]) + 0.5 * sin(2 * x[1])))

gD_fun = u_ex_fun

uh, ph, mesh, H1error, L2error = solve_stokes(20, 2, 1, gD_fun, f_fun,1.,0.0001) # P2/P1 elements

x = SpatialCoordinate(mesh)
u_ex = u_ex_fun(x)

#print('L2 error on u = ', errornorm(u_ex, uh, 'L2'))
print('H1 error on u = ', errornorm(u_ex, uh, 'H1'))

"""Convergence of Velocity, P2 P1 Stabilized, Order 2"""

errvecH1 = []
errvecL2 = []
Nvec = np.array([10, 20, 40])

for n in Nvec:
  uh, ph, mesh, H1error, L2error = solve_stokes(n, 1, 1, gD_fun, f_fun,1.,0.0001)
  errvecH1.append(H1error)
  errvecL2.append(L2error)

# Estimate the order of convergence
u_H1 = (np.log(errvecH1[0]) - np.log(errvecH1[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
u_L2 = (np.log(errvecL2[0]) - np.log(errvecL2[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
print('Order of convergence in H1 norm = ', u_H1)
print('Order of convergence in L2 norm = ', u_L2)

fig, ax = plt.subplots()
ax.loglog(Nvec, errvecH1, 'x', label='Norm H1') # NORM H1
ax.loglog(Nvec, 1/Nvec,color='r', label='Order 1') # CONVERGENCE OF ORDER 1
#ax.loglog(Nvec, errvecL2, 'o', label='Norm L2') # NORM L2
ax.loglog(Nvec, 1/Nvec**2,color='b', label='Order 2') # CONVERGENCE OF ORDER 2
ax.legend()
plt.title('Convergence of Velocity, P2 P1 Stabilized, Order 2')

"""Convergence of Velocity, P1 P1, Stabilized, Order 2"""

errvecH1 = []
errvecL2 = []
Nvec = np.array([10, 20, 40])

for n in Nvec:
  uh, ph, mesh, H1error, L2error = solve_stokes(n, 1, 1, gD_fun, f_fun,1.,0.0001)
  errvecH1.append(H1error)
  errvecL2.append(L2error)

# Estimate the order of convergence
u_H1 = (np.log(errvecH1[0]) - np.log(errvecH1[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
u_L2 = (np.log(errvecL2[0]) - np.log(errvecL2[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
print('Order of convergence in H1 norm = ', u_H1)
print('Order of convergence in L2 norm = ', u_L2)

fig, ax = plt.subplots()
ax.loglog(Nvec, errvecH1, 'x', label='Norm H1') # NORM H1
#ax.loglog(Nvec, 1/Nvec,color='r', label='Order 1') # CONVERGENCE OF ORDER 1
#ax.loglog(Nvec, errvecL2, 'o', label='Norm L2') # NORM L2
ax.loglog(Nvec, 1/Nvec**2,color='b', label='Order 2') # CONVERGENCE OF ORDER 2
ax.legend()
plt.title('Convergence of Velocity, P1 P1, Stabilized, Order 2')

"""No solving the problem with penalty method without checking the convergence
P1 P1 Element Penalty stabilization
"""

uh, ph, mesh, H1error, L2error = solve_stokes(30, 1, 1, gD_fun, f_fun,1.,0.0001) # P1/P1 elements
print('L2 error on u = ', L2error)
print('H1 error on u = ', H1error)

x = SpatialCoordinate(mesh)
u_ex = u_ex_fun(x)

import numpy as np
from sympy import * # Symbolic computations

x, y = symbols('x y')
u = y*(1-y)*cos(pi*x/2)

laplacian_u = simplify(diff(u, x, x) + diff(u, y, y))
grad_u = (diff(u_ex, x),diff(u_ex, y))
f = -laplacian_u
print(f)

# POINT 2
# THE DIRICHLET CONDITION MUST HOLD FOR ALL EDGES
u_bound1 = u_ex.subs({x: x, y: 0}) # BOTTOM
print(u_bound1)
u_bound2 = u_ex.subs({x: x, y: 1}) # UPPER
print(u_bound2)
u_bound3 = u_ex.subs({x: 0, y: y}) # LEFT
print(u_bound3)
u_bound4 = u_ex.subs({x: 1, y: y}) # RIGHT
print(u_bound4)

"""# EXAM 4 12/01/2024
- Exercise 1: ELLIPTIC PROBLEM, GOOD CONVERGENCE, SIMPY
- Exercise 2: ADVECTION DIFFUSION, INTERPOLATION, STABILIZATION

## Exercise 1: ELLIPTIC PROBLEM, GOOD CONVERGENCE, SIMPY

# POINT 1
import numpy as np
from sympy import * # Symbolic computations

x, y = symbols('x y')
u = (2*(1+y))/((3+x)**2+(1+y)**2)

laplacian_u = simplify(diff(u, x, x) + diff(u, y, y))
grad_u = (diff(u_ex, x),diff(u_ex, y))
f = -laplacian_u
print(f)

# POINT 2
# THE DIRICHLET CONDITION MUST HOLD FOR ALL EDGES
u_bound1 = u_ex.subs({x: x, y: 0}) # BOTTOM
print(u_bound1)
u_bound2 = u_ex.subs({x: x, y: 1}) # UPPER
print(u_bound2)
u_bound3 = u_ex.subs({x: 0, y: y}) # LEFT
print(u_bound3)
u_bound4 = u_ex.subs({x: 1, y: y}) # RIGHT
print(u_bound4)
"""

# POINT 4
def solver2D(N):

  # DISCRETIZATION
  mesh = UnitSquareMesh(N, N, diagonal='left') # (N, N, diagonal='left' or 'right')
  V = FunctionSpace(mesh, 'P', 2)
  x = SpatialCoordinate(mesh) # Needed later

  # DIRICHLET BCS
  bc = DirichletBC(V, ((2*(1+x[1]))/((3+x[0])**2+(1+x[1])**2)), "on_boundary")
  #bc = DirichletBC(V, Constant(0.), "on_boundary")

  # VARIATIONAL FORMULATION
  u = TrialFunction(V)
  v = TestFunction(V)

  # FORCING TERM
  f = Constant(0.) # FIREDRAKE OBJECT

  a = dot(grad(u), grad(v)) * dx
  L = f*v*dx

  # SOLUTION
  u_h = Function(V)
  solve(a==L, u_h, bcs=bc)

  u_ex_fd = ((2*(1+x[1]))/((3+x[0])**2+(1+x[1])**2))
  H1error = errornorm(u_ex_fd, u_h, norm_type='H1')
  L2error = errornorm(u_ex_fd, u_h, norm_type='L2')

  return u_h, mesh, H1error, L2error

N = 10
u_h, mesh, H1error, L2error = solver2D(N)

# PLOT SOLUTION
fig, ax = plt.subplots() # being 1 the free stream temperature
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q)

# PLOT ERROR
x = SpatialCoordinate(mesh)
u_ex = ((2*(1+x[1]))/((3+x[0])**2+(1+x[1])**2))
Vaux = FunctionSpace(mesh, 'Lagrange', 3) # SHOULD BE HIGHER ORDER SPACE

fig, ax = plt.subplots()
q = fdplt.tripcolor(project(u_ex - u_h, Vaux), axes=ax)
fig.colorbar(q)

errvecH1 = []
errvecL2 = []

Nvec = np.array([10, 50, 100])
for N in Nvec:
  u_h, mesh, H1error, L2error = solver2D(N) # SOLVING FUNCTION
  errvecH1.append(H1error)
  errvecL2.append(L2error)

# Estimate the order of convergence
p_H1 = (np.log(errvecH1[0]) - np.log(errvecH1[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
p_L2 = (np.log(errvecL2[0]) - np.log(errvecL2[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
print('Order of convergence in H1 norm = ', p_H1)
print('Order of convergence in L2 norm = ', p_L2)
# The solution is in H1 but not in H2, thus the convergence rate

fig, ax = plt.subplots()
ax.loglog(Nvec, errvecH1, 'x','Norm H1') # ERROR WRT NORM H1
ax.loglog(Nvec, errvecL2, 'o','Norm H1')  # ERROR WRT NORM L2
ax.loglog(Nvec, 1/Nvec,color='r', label='Order 1') # CONVERGENCE OF ORDER 1
ax.loglog(Nvec, 1/Nvec**2,color='b', label='Order 2') # CONVERGENCE OF ORDER 2
ax.legend()

"""## Exercise 2: ADVECTION DIFFUSION, INTERPOLATION, STABILIZATION"""

def solve_AD(n, degree, delta, rho):
  # 1. mesh generation
  mesh = UnitSquareMesh(n, n)

  # 2. definition of finite element space
  V = FunctionSpace(mesh, 'P', degree)
  x = SpatialCoordinate(mesh)
  #gD = u_ex(x)
  #bc = DirichletBC(V, gD, 'on_boundary')
  bc = DirichletBC(V,  Constant(0.), (2, 3, 4)) # DIRICHLET ON 1 and 2 boundary

  # 3. assembling bilinear form and linear functionals
  u = TrialFunction(V)
  v = TestFunction(V)

  # PROBLEM DATA
  mu = Constant(1e-3) # PROBLEM DATA
  b = as_vector([x[1]*(x[1] - 1),0])
  #b = as_vector([-1,-1])
  f = Constant(1.) # SOURCE TERM

  # VARIATIONAL FORMULATIONS
  a = (mu * dot(grad(u), grad(v)) + dot(b, grad(u)) * v) * dx
  gN = Constant(1)
  L = f * v * dx + mu * gN * v * ds(1)

  # Stabilization term
  h = CellDiameter(mesh)
  bnorm = sqrt(dot(b, b))
  Pe = bnorm*h/(2*mu)
  tau = 0.5*delta*h/bnorm * conditional(Pe/3 > 1, 1, Pe/3)

  # STRONGLY CONSISTENT METHODS: SUPG and GLS, PART 1
  # THIS IS THE SUM OF THE INTEGRALS ON THE ELEMENTS, NOT AN INTEGRAL ON THE ENTIRE
  # DOMAIN, THERE ARE JUMPS IN THE GRADIENTS BETWEEN TWO ELEMENTS
  R = lambda uu: -mu * div(grad(uu)) + dot(b, grad(uu))
  P = lambda uu: rho *(-mu * div(grad(uu))) + dot(b, grad(uu))
  c_strong = tau * R(u) * P(v) * dx # FIRST STABILIZATION TERM LHS
  a_stab = a + c_strong

  # STRONGLY CONSISTENT METHODS: SUPG and GLS, PART 2, ONLY FOR NON HOMOGENEOUS PROBLEMS
  d_strong = f * P(v) * dx # SECOND STABILIZATION RHS
  #L_stab = L + d_strong

  # STREAMLINE DIFFUSION STABILIZATION
  c_stream = tau * dot(b, grad(u)) * dot(b, grad(v)) * dx # STABILIZATION TERM
  # a_stab = a + c_stream

  # 4. solving discrete problem
  u_h = Function(V)
  solve(a_stab == L, u_h, bc) # STABILIZED HOMOGENEOUS
  #solve(a_stab == L_stab, u_h, bc) # STABILIZED NON HOMOGENEOUS
  #solve(a == L, u_h, bc) # NOT STABILIZED

  return u_h, mesh

n = 10
degree = 1

# NOT STABILIZED
delta = Constant(0.)
rho = Constant(0.)
u_h, mesh = solve_AD(n, degree, delta, rho)

fig, ax = plt.subplots()
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q, fraction=0.045)
plt.title('NOT STABILIZED')

# STABILIZED
delta = Constant(1.)

rho = Constant(0.) # SUPG
u_h_supg, mesh = solve_AD(n, degree, delta, rho)

fig, ax = plt.subplots()
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q, fraction=0.045)
plt.title('SUPG')

rho = Constant(1.) # GLS
u_h_gls, mesh = solve_AD(n, degree, delta, rho)

fig, ax = plt.subplots()
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q, fraction=0.045)
plt.title('GLS')

N = 10

degree = 1
# SOLUTION
u_h_supg, mesh = solve_AD(N, degree, 1., 0.) # SUPG
u_h_gls, mesh = solve_AD(N, degree, 1., 1.)  # GLS

# ALTERNATIVE TO INTERPOLATION
V = FunctionSpace(mesh, 'P', degree+1)
u_h_supg = project(u_h_supg, V)
u_h_gls = project(u_h_gls, V)
L2error = errornorm(u_h_supg, u_h_gls, norm_type='L2')

# INTERPOLATION
# from firedrake.__future__ import interpolate
#V = u_h_supg.function_space()  # Get the function space of u_h_supg
#u_h_gls_interp = Function(V)
#u_h_gls_interp.assign(assemble(interpolate(u_h_gls, V)))
#L2error = errornorm(u_h_gls_interp, u_h_supg, norm_type='L2')

print('Degree 1 distance L2:',L2error)

degree = 2
# SOLUTION
u_h_supg, mesh = solve_AD(N, degree, 1., 0.) # SUPG
u_h_gls, mesh = solve_AD(N, degree, 1., 1.)  # GLS

# ALTERNATIVE TO INTERPOLATION
V = FunctionSpace(mesh, 'P', degree+1)
u_h_supg = project(u_h_supg, V)
u_h_gls = project(u_h_gls, V)
L2error = errornorm(u_h_supg, u_h_gls, norm_type='L2')

# INTERPOLATION
#V = u_h_supg.function_space()  # Get the function space of u_h_supg
#u_h_gls_interp = Function(V)
#u_h_gls_interp.assign(assemble(interpolate(u_h_gls, V)))

#L2error = errornorm(u_h_gls_interp, u_h_supg, norm_type='L2')
print('Degree 2 distance L2:',L2error)

# IN THE STABILIZATION TECHNIQUE THE LAPLACIAN IS COMPUTED ELEMENT BY ELEMENT, BECAUSE THERE ARE JUMPS
# IN GRADIENT BETWEEN THE ELEMENTS
# THE GRADIENT FOR P1 ELEMENTS IS CONSTANT, THE DIVERGENCE FOR A CONSTANT IS ZERO,
# SO THE LAPLACIAN IS ZERO IN EACH ELEMENT.
# WHAT REMAINS NON ZERO IS THE SAME TERM AS STREAMLINE DIFFUSION STABILIZATION
# SO USING P1, DEGREE 1 POLINOMIALS, THE SOLUTION IS THE SAME FOR STREAMLINE DIFFUSION METHOD, GLS AND SUPG
# WITH P2 THERE IS A DIFFERENCE

"""# TDE 5 06/02/2024
- Exercise 1: ELLIPTIC PROBLEM 2D, K MATRIX GENERAL FORMULATION k 2x2, NO BCS FOR ONE EDGE OF BOUNDARY
- Exercise 2: STOKES SYSTEM, NEUMANN BCS: GENERAL AND PARTICULAR CASE (POISSEUILLE), DIRICHLET HOM AND NOT HOM

## Exercise 1: K MATRIX GENERAL FORMULATION, ELLIPTIC PROBLEM 2D
"""

mesh = UnitSquareMesh(N, N)
V = FunctionSpace(mesh, 'P', 1)
x = SpatialCoordinate(mesh)

fig, ax = plt.subplots()     # to recognize every part of the boundary
fdplt.triplot(mesh, axes=ax) # 1, 2 -> Dirichlet boundary 3 -> Neumann boundary
ax.legend()                  # 4 -> Robin boundary

def solver2D(N):

  # DISCRETIZATION
  mesh = UnitSquareMesh(N, N)
  V = FunctionSpace(mesh, 'P', 2)
  x = SpatialCoordinate(mesh)

  # DIRICHLET BCS
  bc = DirichletBC(V, Constant(0.), (1, 3, 4))

  # VARIATIONAL FORMULATION
  u = TrialFunction(V)
  v = TestFunction(V)

  # PROBLEM DATA
  f = Constant(1.)
  k = as_matrix([[1, 0],[0, 2]])

  a = dot(dot(k, grad(u)), grad(v)) * dx
  L = f*v*dx

  # SOLUTION
  u_h = Function(V)
  solve(a==L, u_h, bc)

  return u_h, mesh

N = 10
u_h, mesh = solver2D(N)

fig, ax = plt.subplots()
q = tricontourf(u_h, axes=ax)
plt.colorbar(q)

"""## Exercise 2: STOKES SYSTEM, NEUMANN BCS: GENERAL AND PARTICULAR CASE (POISSEUILLE), DIRICHLET HOM AND NOT HOM
Neumann Bcs are enforced dividing the form in two parts:
- RHS Py * dot(n, v) * ds(2) KNOWN
- LHS dot(dot(grad(u), n),v) * ds(4) UNKNOWN

### PARTICULAR FORMULATION: LESS GENERAL FORMULATION FOR STOKES SYSTEM WITH NEUMANN BCS:
In this form the term dU/dN = grad(U) N, U and N vectors IS NOT PRESENT, it cancels out in previous computations, THIS IS A PARTICULAR CASE, below the general case
"""

# H1 VELOCITY L2 PRESSURE WITH P2 P1
def solve_stokes(degreeU, degreeP, f_fun, delta, epsilon):
    # Mesh definition
    mesh = RectangleMesh(20, 10, 4., 1., diagonal='crossed')
    V = VectorFunctionSpace(mesh, 'CG', degreeU)
    Q = FunctionSpace(mesh, 'CG', degreeP)
    W = MixedFunctionSpace([V, Q])

    x = SpatialCoordinate(mesh)

    a = 0.1
    gD = as_vector(( 0.5*(a-sin(pi/6))*x[1]*(x[1]-1) , 0.))
    f = f_fun(x)
    Py = a*x[0]+ x[1]*(-cos(pi/6))

    # DIRICHLET
    bc0 = DirichletBC(W.sub(0), gD, 1)
    bc1 = DirichletBC(W.sub(0), Constant((0., 0.)), (3,4))

    # Handle the pressure indetermination by specifying the nullspace
    # see https://www.firedrakeproject.org/solving-interface.html#singular-operators-in-mixed-spaces
    # According to the documentation, we provide a basis for the nullspace of pressure
    # For velocity, we pass the whole space, signifying that "we don't care about" it
    nullspace = MixedVectorSpaceBasis(
        W, [W.sub(0), VectorSpaceBasis(constant=True)]
    )

    # Variational formulation
    u, p = TrialFunctions(W)
    v, q = TestFunctions(W)

    n = FacetNormal(mesh)

    # PARTICULAR CASE
    # LESS GENERAL FORMULATION FOR STOKES SYSTEM WITH NEUMANN BCS:
    # IN THIS FORM THE TERM dU/dN = grad(U) N, U and N vectors IS NOT PRESENT,
    # IT CANCEL OUT IN PREVIOUS COMPUTATIONS,
    # THIS IS A PARTICULAR CASE
    a = inner(grad(u), grad(v)) * dx - div(v) * p * dx - q * div(u) * dx
    L = dot(f, v) * dx - Py * dot(n, v) * ds(2)

    # Brezzi-Pitkaranta stabilization
    h = CellDiameter(mesh)
    a_stab = Constant(delta) * h * h * dot(grad(p), grad(q)) * dx
    #a -= a_stab

    # Pressure Stabilization
    a_pressure = Constant(epsilon) * dot(grad(p), grad(q)) * dx
    #a -= a_pressure

    # Penalty Stabilization
    a_penalty = Constant(epsilon) * p * q * dx
    #a += a_penalty

    # Solution
    w = Function(W)
    solve(a==L, w, (bc0, bc1), nullspace=nullspace)
    uh, ph = w.subfunctions

    #pmean = assemble(ph*dx) # ACTIVATE WHEN STABILIZING FOR CONVERGENCE OF ORDER 1
    #ph -= pmean

    return uh, ph, mesh

f_fun = lambda x: as_vector(([Constant(sin(pi/6)),Constant(-cos(pi/6))]))
u_ex = lambda x: as_vector(([Constant( ((a-sin(pi/6))/2)*x[1]*(x[1]-1) ),Constant(0.)]))

uh, ph, mesh = solve_stokes(2, 1, f_fun, 1.,0.0001) # P2/P1 elements

fig, ax = plt.subplots(2, 1) # grid of 2 rows 1 colums
quiver(uh, axes=ax[0])
tripcolor(ph, axes=ax[1])
ax[0].set_aspect('equal')
ax[1].set_aspect('equal')

fig, ax = plt.subplots()
q = tricontour(ph, axes=ax)
plt.colorbar(q)
ax.set_aspect('equal')

"""### GENERAL FORMULATION FOR STOKES SYSTEM WITH NEUMANN BCS:
In this form the term dU/dN = grad(U) N, U and N vectors IS PRESENT, this is the general case, its presence depends on the expressions of U=[Ux,Uy] and the enforced BCS
"""

# H1 VELOCITY L2 PRESSURE WITH P2 P1
def solve_stokes(degreeU, degreeP, f_fun, delta, epsilon):
    # Mesh definition
    mesh = RectangleMesh(20, 10, 4., 1., diagonal='crossed')
    V = VectorFunctionSpace(mesh, 'CG', degreeU)
    Q = FunctionSpace(mesh, 'CG', degreeP)
    W = MixedFunctionSpace([V, Q])

    x = SpatialCoordinate(mesh)

    a = 0.1
    gD = as_vector(( 0.5*(a-sin(pi/6))*x[1]*(x[1]-1) , 0.))
    f = f_fun(x)
    Py = a*x[0]+ x[1]*(-cos(pi/6))

    # DIRICHLET
    bc0 = DirichletBC(W.sub(0), gD, 1)
    bc1 = DirichletBC(W.sub(0), Constant((0., 0.)), (3,2))

    # Handle the pressure indetermination by specifying the nullspace
    # see https://www.firedrakeproject.org/solving-interface.html#singular-operators-in-mixed-spaces
    # According to the documentation, we provide a basis for the nullspace of pressure
    # For velocity, we pass the whole space, signifying that "we don't care about" it
    nullspace = MixedVectorSpaceBasis(
        W, [W.sub(0), VectorSpaceBasis(constant=True)]
    )

    # Variational formulation
    u, p = TrialFunctions(W)
    v, q = TestFunctions(W)

    n = FacetNormal(mesh)

    # IMPORTANT: GENERAL VARIATIONAL FORMULATION FOR STOKES SYSTEM WITH NEUMANN BCS FOURTH TERM IS ADDED
    a = inner(grad(u), grad(v)) * dx - div(v) * p * dx - q * div(u) * dx + dot(dot(grad(u), n),v) * ds(4)
    L = dot(f, v) * dx - Py * dot(n, v) * ds(4)

    # Brezzi-Pitkaranta stabilization
    h = CellDiameter(mesh)
    a_stab = Constant(delta) * h * h * dot(grad(p), grad(q)) * dx
    #a -= a_stab

    # Pressure Stabilization
    a_pressure = Constant(epsilon) * dot(grad(p), grad(q)) * dx
    #a -= a_pressure

    # Penalty Stabilization
    a_penalty = Constant(epsilon) * p * q * dx
    #a += a_penalty

    # Solution
    w = Function(W)
    solve(a==L, w, (bc0, bc1), nullspace=nullspace)
    uh, ph = w.subfunctions

    #pmean = assemble(ph*dx) # ACTIVATE WHEN STABILIZING FOR CONVERGENCE OF ORDER 1
    #ph -= pmean

    return uh, ph, mesh

f_fun = lambda x: as_vector(([Constant(sin(pi/6)),Constant(-cos(pi/6))]))
u_ex = lambda x: as_vector(([Constant( ((a-sin(pi/6))/2)*x[1]*(x[1]-1) ),Constant(0.)]))

uh, ph, mesh = solve_stokes(2, 1, f_fun, 1.,0.0001) # P2/P1 elements

fig, ax = plt.subplots(2, 1) # grid of 2 rows 1 colums
quiver(uh, axes=ax[0])
tripcolor(ph, axes=ax[1])
ax[0].set_aspect('equal')
ax[1].set_aspect('equal')

fig, ax = plt.subplots()
q = tricontour(ph, axes=ax)
plt.colorbar(q)
ax.set_aspect('equal')

"""# TDE 6 24/06/2024
- EXXERCISE 1: ADVECTION REACTION
- EXERCISE 2: UNSTEADY STOKES SYSTEM (LINEAR)

## EXERCISE 1 - ADVECTION REACTION
"""

def solveAR(N, u_ex):

  N = 10
  mesh = UnitSquareMesh(N, N) # mesh
  V = FunctionSpace(mesh, 'P', 1) # function space
  x = SpatialCoordinate(mesh)

  gD = u_ex(x)
  bc = DirichletBC(V, gD, 'on_boundary')

  mu = Constant(1.)
  sigma = Constant(-1/(4*(pi**2)))
  f = 5*(pi**2)*sin(pi*x[0])*sin(2*pi*x[1]) + r*sin(pi*x[0])*sin(2*pi*x[1]) + r*x[0]

  # WITHOUT LUMPING MASS MATRIX
  u = TrialFunction(V)
  v = TestFunction(V)

  a = mu * dot(grad(u), grad(v)) * dx + sigma * u * v * dx
  L = f * v * dx

  u_h = Function(V)
  solve(a==L, u_h, bcs=(bc))

  return u_h, mesh

n = 10
u_ex = lambda x: sin(pi*x[0])*sin(2*pi*x[1])+x[0]
u_h, mesh = solve_AR(n, u_ex)
fig, ax = plt.subplots()
#q = fdplt.tripcolor(u_h, axes=ax) # WRONG
q = fdplt.tricontourf(u_h, axes=ax) # RIGHT
plt.colorbar(q)

# it is possible tot see that the solution is negative, while it shouldn't be
# that is because of oscillations

# POINT 2
import numpy as np
from sympy import * # Symbolic computations

x, y, r = symbols('x y r')
u = sin(pi*x)*sin(2*pi*y)+x
print('u_ex:',u)

laplacian_u = simplify(diff(u, x, x) + diff(u, y, y))
grad_u = (diff(u, x),diff(u, y))
f = -laplacian_u - r*u
print('f:',simplify(f))

# POINT 2
# THE DIRICHLET CONDITION MUST HOLD FOR ALL EDGES
u_bound1 = u.subs({x: x, y: 0}) # BOTTOM
print(u_bound1)
u_bound2 = u.subs({x: x, y: 1}) # UPPER
print(u_bound2)
u_bound3 = u.subs({x: 0, y: y}) # LEFT
print(u_bound3)
u_bound4 = u.subs({x: 1, y: y}) # RIGHT
print(u_bound4)

def solve_AR(n, degree, g_D):

  # PHYSICAL DATA
  mu = Constant(1.)
  sigma = Constant(-1/(4*(pi**2)))

  # DISCRETIZATION
  mesh = UnitSquareMesh(n, n)
  V = FunctionSpace(mesh, 'P', degree)
  x = SpatialCoordinate(mesh)

  # BCS
  gD = g_D(x)
  bc = DirichletBC(V, gD, 'on_boundary')

  # VARIATIONAL FORMULATION
  u = TrialFunction(V)
  v = TestFunction(V)

  f = sigma*(x[0] + sin(pi*x[0])*sin(2*pi*x[1])) + 5*pi**2*sin(pi*x[0])*sin(2*pi*x[1])

  a = mu*dot(grad(u), grad(v))*dx + sigma*u*v*dx
  L = f*v*dx

  u_h = Function(V)

  solve(a==L, u_h, bc)

  u_ex = sin(pi*x[0])*sin(2*pi*x[1])+x[0]

  errH1 = errornorm(u_ex, u_h, 'H1')
  errL2 = errornorm(u_ex, u_h, 'L2')

  return u_h, mesh, errH1, errL2

n = 10
degree = 1
gD = lambda x: sin(pi*x[0])*sin(2*pi*x[1])+x[0]
u_h, mesh, errH1, errL2 = solve_AR(n, degree, gD)

fig, ax = plt.subplots()
q = tricontourf(u_h, axes=ax)
plt.colorbar(q)

errvecH1 = []
errvecL2 = []
Nvec = np.array([10, 20, 40])

for n in Nvec:
  u_h, mesh, errH1, errL2 = solve_AR(n, degree, gD)
  errvecH1.append(errH1)
  errvecL2.append(errL2)

# Estimate the order of convergence
u_H1 = (np.log(errvecH1[0]) - np.log(errvecH1[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
u_L2 = (np.log(errvecL2[0]) - np.log(errvecL2[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
print('Order of convergence in H1 norm = ', u_H1)
print('Order of convergence in L2 norm = ', u_L2)

fig, ax = plt.subplots()
ax.loglog(Nvec, errvecH1, 'x', label='Norm H1') # NORM H1
ax.loglog(Nvec, 1/Nvec,color='r', label='Order 1') # CONVERGENCE OF ORDER 1
ax.loglog(Nvec, errvecL2, 'o', label='Norm L2') # NORM L2
ax.loglog(Nvec, 1/Nvec**2,color='b', label='Order 2') # CONVERGENCE OF ORDER 2
ax.legend()
plt.title('Convergence AR')

"""## EXERCISE 2: UNSTEADY STOKES SYSTEM (LINEAR)"""

n = 10
mesh = UnitSquareMesh(n, n, diagonal='crossed')
x = SpatialCoordinate(mesh)

fig, ax = plt.subplots()     # to recognize every part of the boundary
fdplt.triplot(mesh, axes=ax)
ax.legend()

#f_fun = lambda t: as_vector((0., -500.))
f_fun = as_vector((0., -500.))


T = 1.

# Backward Euler, explicit advection
t = 0
#dt = 0.05
dt = 0.1

V = VectorFunctionSpace(mesh, 'P', 2)
Q = FunctionSpace(mesh, 'P', 1)
W = MixedFunctionSpace([V, Q])

nullspace = MixedVectorSpaceBasis(
    W, [W.sub(0), VectorSpaceBasis(constant=True)]
)

u_pre = project(Constant((0., 0.)), W.sub(0))

u, p = TrialFunctions(W)
v, q = TestFunctions(W)

# In this case, the system matrix is the same at each iteration

#a = (1/dt * dot(u, v) - p * div(v) + q * div(u) + 1/Re * inner(grad(u), grad(v))) * dx
a = (1/dt * dot(u, v) - p * div(v) + q * div(u) + inner(grad(u), grad(v))) * dx

while t<T:
    t += dt

    #f = f_fun(t)

    #u_ex = u_ex_fun(t)
    #p_ex = p_ex_fun(t)
    #gD = u_ex_fun(t)
    #bc = DirichletBC(W.sub(0), gD, 'on_boundary')
    bc1 = DirichletBC(W.sub(0), as_vector((sin(2*pi*t), 0.)), 4)
    bc2 = DirichletBC(W.sub(0), as_vector((0., 0.)), (1,2,3))


    # The right hand side needs to be updated
    # L = (1/dt * dot(u_pre, v) - dot(dot(grad(u_pre), u_pre), v) + dot(f, v)) * dx
    L = (1/dt * dot(u_pre, v) + dot(f, v)) * dx

    w = Function(W)
    solve(a==L, w, (bc1, bc2), nullspace=nullspace)

    u, p = w.subfunctions

    # Optional: plot the solution at each time
    #fig, ax = plt.subplots(1, 2)
    #q0 = tripcolor(p, axes=ax[0])
    #plt.colorbar(q0)
    #q1 = tripcolor(interpolate(p_ex, W.sub(1)), axes=ax[1])
    #plt.colorbar(q1)

    fig, ax = plt.subplots(2, 1) # grid of 2 rows 1 colums
    u0 = quiver(u, axes=ax[0])
    plt.colorbar(u0)
    q0 = tripcolor(p, axes=ax[1])
    plt.colorbar(q0)
    ax[0].set_aspect('equal')
    ax[1].set_aspect('equal')

    #norm_u_H1 = norm(project(u_ex, VectorFunctionSpace(mesh, 'P', 2)), 'H1')
    #err_u_H1 = errornorm(u_ex, u, 'H1')
    #norm_p_L2 = norm(project(p_ex, FunctionSpace(mesh, 'P', 1)), 'L2')
    #err_p_L2 = errornorm(p_ex, p, 'L2')

    #h = 1/n
    #print('h = ', h)
    #umax = np.max(u.dat.data)

    print('t = ', t)
    #print('H1 error, u = ', err_u_H1)
    #print('Relative H1 error, u = ', err_u_H1/norm_u_H1)
    #print('L2 error, p = ', err_p_L2)
    #print('Relative L2 error, p = ', err_p_L2/norm_p_L2)
    #print('Courant number = ', umax*dt/h)
    #print('\n')

    u_pre.assign(u)

"""# TDE 7 15/07/2024
- Exercise 1: ELLIPTIC PROBLEM, GALERKIN ORTHOGONALITY ASSEMBLE, CONVERGENCE
- EXERCISE 2: STOKES SYSTEM, USAGE OF RECTANGLE MESH -1 TO 1 BOUNDS, CONVERGENCE

## Exercise 1: ELLIPTIC PROBLEM, GALERKIN ORTHOGONALITY ASSEMBLE, CONVERGENCE
"""

mesh = UnitSquareMesh(N, N)
V = FunctionSpace(mesh, 'P', 1)
x = SpatialCoordinate(mesh)

fig, ax = plt.subplots()     # to recognize every part of the boundary
fdplt.triplot(mesh, axes=ax) # 1, 2 -> Dirichlet boundary 3 -> Neumann boundary
ax.legend()                  # 4 -> Robin boundary

def solver2D(N):

  # DISCRETIZATION
  mesh = UnitSquareMesh(N, N)
  V = FunctionSpace(mesh, 'P', 2)
  x, y = SpatialCoordinate(mesh)

  # DIRICHLET BCS
  bc = DirichletBC(V, Constant(0.), (1,2,3,4))

  # VARIATIONAL FORMULATION
  u = TrialFunction(V)
  v = TestFunction(V)

  # PROBLEM DATA
  f = -pi**2*y*(y-1)*sin(pi*x) - pi * (2*y-1) * cos(pi*x) + 2 * sin(pi*x)
  k = as_matrix([[4, -2],[-2, 4]])

  #a = dot(grad(u), dot(k, grad(v))) * dx
  a = dot(k*grad(u), grad(v)) * dx
  L = f*v*dx

  # SOLUTION
  u_h = Function(V)
  solve(a==L, u_h, bc)

  u_ex =  1/4 * y * (1-y) * sin(pi*x)

  orthogonality = assemble( dot(dot(k, grad(u_h-u_ex)), grad(u_h)) * dx)
  print('Orthogonality:',orthogonality)

  errH1 = errornorm(u_ex, u_h, 'H1')

  return u_h, mesh, errH1

N = 50
u_h, mesh, errH1 = solver2D(N)

fig, ax = plt.subplots()
q = tricontourf(u_h, axes=ax)
plt.colorbar(q)

errvecH1 = []
Nvec = np.array([5, 10, 100])
for N in Nvec:
  u_h, mesh, err = solver2D(N)
  x = SpatialCoordinate(mesh)
  u_ex =  1/4 * x[1] * (1-x[1]) * sin(pi*x[0])
  H1error = errornorm(u_ex, u_h, 'H1')
  errvecH1.append(H1error)

# Estimate the order of convergence
p_H1 = (np.log(errvecH1[0]) - np.log(errvecH1[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
print('Order of convergence in H1 norm = ', p_H1)

fig, ax = plt.subplots()
ax.loglog(Nvec, errvecH1, 'x')
ax.loglog(Nvec, 1/Nvec,color='r', label='Order 1') # CONVERGENCE OF ORDER 1
ax.loglog(Nvec, 1/Nvec**2,color='b', label='Order 2') # CONVERGENCE OF ORDER 2
ax.legend()

"""## EXERCISE 2: STOKES SYSTEM, USAGE OF RECTANGLE MESH -1 TO 1 BOUNDS, CONVERGENCE"""

mesh = UnitSquareMesh(10, 10)
fig, ax = plt.subplots()     # to recognize every part of the boundary
fdplt.triplot(mesh, axes=ax) # 1, 2 -> Dirichlet boundary 3 -> Neumann boundary
ax.legend()                  # 4 -> Robin boundary

def solve_stokes(n, degreeU, degreeP, gD, f_fun, delta, epsilon):
    # Mesh definition
    mesh = RectangleMesh(n, n, 1, 1, -1, -1)
    # DISCRETIZATION INTERVALS, ONE VALUE ALONG X AND ONE VALUE FOR Y
    # FOUR VALUES FO THE BOUNDS

    V = VectorFunctionSpace(mesh, 'P', degreeU)
    Q = FunctionSpace(mesh, 'P', degreeP)
    W = MixedFunctionSpace([V, Q])
    x = SpatialCoordinate(mesh)

    gD = gD(x)
    f = f_fun(x)
    bc1 = DirichletBC(W.sub(0), gD, 'on_boundary')

    nullspace = MixedVectorSpaceBasis(
        W, [W.sub(0), VectorSpaceBasis(constant=True)]
    )

    # Variational formulation
    u, p = TrialFunctions(W)
    v, q = TestFunctions(W)

    a = inner(grad(u), grad(v)) * dx - div(v) * p * dx - q * div(u) * dx
    L = dot(f, v) * dx

    # Brezzi-Pitkaranta stabilization
    h = CellDiameter(mesh)
    a_stab = Constant(delta) * h * h * dot(grad(p), grad(q)) * dx
    #a -= a_stab

    # Pressure Stabilization
    a_pressure = Constant(epsilon) * dot(grad(p), grad(q)) * dx
    #a -= a_pressure

    # Penalty Stabilization
    a_penalty = Constant(epsilon) * p * q * dx
    #a += a_penalty

    # Solution
    w = Function(W)
    solve(a == L, w, bc1, nullspace=nullspace)
    uh, ph = w.subfunctions

    #pmean = assemble(ph*dx) # ACTIVATE WHEN STABILIZING FOR CONVERGENCE OF ORDER 1
    #ph -= pmean

    u_ex_fun = lambda x: as_vector(( 20*x[0]*x[1]**3, 5*x[0]**4 - 5*x[1]**4 ))
    p_ex_fun = lambda x: 60*x[0]**2*x[1] - 20*x[1]**3

    u_ex = u_ex_fun(x)
    p_ex = p_ex_fun(x)

    # Error norm of the velocity in H1
    u_errH1 = errornorm(u_ex, uh, 'H1')

    # Error norm of the pressure in L2
    p_errL2 = errornorm(p_ex, ph, 'L2')

    # Composed error
    err = u_errH1 + p_errL2

    return uh, ph, mesh, err

u_ex_fun = lambda x: as_vector(( 20*x[0]*x[1]**3, 5*x[0]**4 - 5*x[1]**4))
p_ex_fun = lambda x: 60*x[0]**2*x[1] - 20*x[1]**3
f_fun = lambda x: as_vector((Constant(0.), Constant(0.)))

gD = u_ex_fun

uh, ph, mesh, err = solve_stokes(20, 2, 1, gD, f_fun,1.,0.0001) # P2/P1 elements
#uh, ph, mesh = solve_stokes(20, 1, 1, gD_fun, f_fun,1.,0.0001) # P2/P1 elements


fig, ax = plt.subplots()
q = tripcolor(ph, axes=ax)
plt.colorbar(q)

fig, ax = plt.subplots()
q = quiver(uh, axes=ax)
plt.colorbar(q)

errvec = []
Nvec = np.array([10, 20, 50])

for N in Nvec:
  uh, ph, mesh, err = solve_stokes(N, 2, 1, gD, f_fun,1.,0.0001) # P2/P1 elements
  errvec.append(err)

# Estimate the order of convergence
u_H1 = (np.log(errvec[0]) - np.log(errvec[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
print('Order of convergence in H1 norm = ', u_H1)

fig, ax = plt.subplots()
ax.loglog(Nvec, errvec, 'x')
ax.loglog(Nvec, 1/Nvec,color='r', label='Order 1') # CONVERGENCE OF ORDER 1
ax.loglog(Nvec, 1/Nvec**2,color='b', label='Order 2') # CONVERGENCE OF ORDER 2
ax.legend()

