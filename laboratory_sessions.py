# -*- coding: utf-8 -*-
"""Laboratory Sessions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pgjsmonX5jxLoQuJP8em95HwfFAC7Mjo

[link text](https://)solve(a==L, u_h, (bc0, bc1))
"""

try:
    import firedrake
except ImportError:
    !wget "https://fem-on-colab.github.io/releases/firedrake-install-real.sh" -O "/tmp/firedrake-install.sh" && bash "/tmp/firedrake-install.sh"
    import firedrake

from firedrake import *
import numpy as np
import finat
import firedrake.pyplot as fdplt
import matplotlib.pyplot as plt
from firedrake.__future__ import interpolate

"""# Laboratory Session 1 - Finite Differencies

WAYS OF BUILDING MATRICES
"""

N = 10

# Sparse representation with NUMPY ARRAY 8*N*N
import numpy as np
A = 2*np.eye(N-2) - np.diag(np.ones(N-3),1) - np.diag(np.ones(N-3),-1)
print('Bytes for numpy array:',A.nbytes) # MATRIX A NUMBER OF BYTES
print('Bytes for each element numpy array:',A.itemsize)
# bytes for each ELEMENT of A = 8

# Sparse representation with NUMPY DIAGS, Number of Elements for tridiagonal matrix = 3N-2
from scipy.sparse import diags
d = 2*np.ones(N-2)
e = -np.ones(N-3)
data = [e, d, e]
diagonals = [-1, 0, 1]
# COO FORMAT 16*(3N-2), for each element its value: float 8 bytes, Its position in the matrix: two integers 2x4 bytes
As = diags(data, diagonals).tocoo()
print('Bytes for numpy diags COO:',As.data.nbytes + As.row.nbytes + As.col.nbytes) #=(8+4+4)*(100 + 99*2)
# CSR FORMAT 40N − 20 bytes
As = diags(data, diagonals).tocsr()
print('Bytes for numpy diags CSR:',As.data.nbytes + As.indices.nbytes + As.indptr.nbytes)

"""COMPUTATIONAL TIME    """

from time import perf_counter
t0 = perf_counter()
# OPERATION TO BE PERFORMED EXAMPLE CONJUGATE GRADIENT (A POSITIVE DEFINITE) VS USUAL SOLVER
#x, info = cg(As, v)
#x = np.linalg.solve(A, v)
tf = perf_counter()
print('Time for sparse multiplication = ', tf - t0)

"""Exercises"""

import numpy as np
import matplotlib.pyplot as plt

#from scipy.sparse import eye # exployting now the sparseness of the matrices

"""## EXERCISE 1"""

# defining function
def solve_poisson_FD(a, b, N, g):
  """
  Solves Poisson eq. on (a, b), with N grid points and forcing term g
  """
  x = np.linspace(a, b, N) # creating grid
  h = x[1]-x[0] # computing interval between grid points
  A = 2*np.eye(N-2) - np.eye(N-2, k=-1) - np.eye(N-2, k=1) # creating tri-diagonal matrix
  f = h**2 * g(x[1:-1]) # creating right hand side, using x a part from first and last term
  u = np.linalg.solve(A,f) # solving the system using a direct method (Gauss elimination)
  return x, u

"""Problem Statement, Error, Convergence"""

a = 0 # setting parameters
b = 2*np.pi
N = 10
g = lambda x: np.sin(x) # lambda cannot be used as a value

# u_h = solve_poisson_FD(a, b, N, g) # solving numerical solution
# in this way using only one output value for a function with two output values I get a tuple with all the returned values, tuple with two arrays
x, u_h = solve_poisson_FD(a, b, N, g) # solving numerical solution
# if instead I use two values in output I get two separated vectors

u_ex = lambda x: np.sin(x) # building exact analytical solution
x_fine = np.linspace(a, b, 500) # using finer grid for plotting

fig, ax = plt.subplots()
ax.plot(x[1:-1], u_h, 'o')
ax.plot(x_fine, u_ex(x_fine), '-')
# Dirichlet condition at boundaries are not included in the function written, because beying a Dirichlet problem we already know that in those points

# computing errors, checking that convergence is of order two, convergence test
Nvec = np.array([10])

errvec = []
for N in Nvec:
  x, u = solve_poisson_FD(a, b, N, g)
  err = np.max(np.abs(u-u_ex(x[1:-1])))
  print('N=', N, ',err=', err)
  errvec.append(err)

fig, ax = plt.subplots()
ax.loglog(Nvec, errvec, 'o')
ax.loglog(Nvec, 1/Nvec**2)
# dot (error) parallel to the line
print('len U:',len(u),'len U_ex',len(u_ex(x[1:-1])))

"""## EXERCISE 2

Numerical Solution
"""

# defining function
def solve_poisson_FD_CONSTANT(a, b, N, g):
  """
  Solves Poisson eq. on (a, b), with N grid points and forcing term g
  TO BE USED WITH CONSTANT FORCING TERM
  """
  x = np.linspace(a, b, N) # creating grid

  # CREATING DUMMY FUNCTION
  fun = np.zeros(N)
  for i in range(0,len(fun)):
     fun[i]=g(1)

  h = x[1]-x[0] # computing interval between grid points
  A = 2*np.eye(N-2) - np.eye(N-2, k=-1) - np.eye(N-2, k=1) # creating tri-diagonal matrix
  f = h**2 * fun[1:-1] # creating right hand side, using x a part from first and last term
  u = np.linalg.solve(A,f) # solving the system using a direct method (Gauss elimination)
  return x, u

"""Problem Statement, Error, Convergence"""

a = 0 # setting parameters
b = 1
N = 400
g = lambda x: 1
x, u_h = solve_poisson_FD_CONSTANT(a, b, N, g) # solving numerical solution

u_ex = lambda x: 1/2*x*(1-x) # building exact analytical solution
x_fine = np.linspace(a, b, 500) # using finer grid for plotting

fig, ax = plt.subplots()
ax.plot(x[1:-1], u_h, 'o')
ax.plot(x_fine, u_ex(x_fine), '-')
err = np.max(np.abs(u_ex(x[1:N-1]) - u_h))
print(err)

# computing errors, checking that convergence is of order two, convergence test
Nvec = np.array([10, 100, 1000])
a = 0 # setting parameters
b = 1
g = lambda x: 1

errvec = []
for N in Nvec:
  x, u = solve_poisson_FD_CONSTANT(a, b, N, g)
  err = np.max(np.abs(u_ex(x[1:N-1]) - u))
  print('N=', N, ',err=', err)
  errvec.append(err)

fig, ax = plt.subplots()
ax.loglog(Nvec, errvec, 'o')
ax.loglog(Nvec, (1/Nvec**2))
# dot (error) parallel to the line
print('len U:',len(u),'len U_ex',len(u_ex(x[1:-1])))

"""## EXERCISE 3"""

def solve_poisson_nd(g, N):
    #nd stands for Neumann-Dirichlet
    x = np.linspace(0.0, 3/2*np.pi, N, endpoint=True)
    dx = x[1]-x[0]


    # Construction of the matrix (this time it is N-1xN-1)
    A = 2*np.eye(N-1) - np.diag(np.ones(N-2),1) - np.diag(np.ones(N-2),-1)
    #print(A)
    # Fixing the first row for Neumann
    A[0, :3] = np.array([-3/2, 2, -1/2]) # second order approximation of the derivative
    #print(A)

    # Construction of the RHS


    # Fixing the first row for Neumann
    rhs[0] = 0

    # Solution of the linear system (Au=g)
    u = np.linalg.solve(A, rhs)

    return x, u

# Solution
def solve_poisson_nd_order1_W(g, N):
    #nd stands for Neumann-Dirichlet
    x = np.linspace(0.0, 3/2*np.pi, N, endpoint=True)
    dx = x[1]-x[0]

    # Fixing the first row for Neumann, in this case, would yield a singular matrix!
    #A[0, :2] = np.array([-1, 1]) # first order approximation of the derivative
    # We thus need to build a smaller matrix and then add condition u[0]=u[1]
    # It corresponds to the second row becoming [1, -1, 0, ... 0]
    # Construction of the matrix (N-2xN-2)
    # RIGHT
    #A = 2*np.eye(N-2) - np.diag(np.ones(N-3),1) - np.diag(np.ones(N-3),-1)
    #A[0, 0] = 1
    # WRONG
    A = 2*np.eye(N-1) - np.diag(np.ones(N-2),1) - np.diag(np.ones(N-2),-1)
    A[0, :2] = np.array([-1, 1])
    print(A)
    print(np.linalg.det(A))

    # Construction of the RHS
    # rhs = dx**2*g(x[1:N-1]) #RIGHT
    rhs = dx**2*g(x[:N-1]) #WRONG
    # Fixing the first row for Neumann
    rhs[0] = 0

    # Solution of the linear system (Au=g)
    u_1N = np.linalg.solve(A, rhs)

    #u = np.zeros(N-1)
    #u[0] = u_1N[0]
    #u[1:] = u_1N

    return x, u_1N

# Solution
def solve_poisson_nd_order1_R(g, N):
  # RIGHT WAY
  # NEUMAN CONDITION -> I CANNOT FIX THE VALUE -> LOSS OF INFORMATION -> MATRIX BECOMES SMALLER

  #nd stands for Neumann-Dirichlet
  x = np.linspace(0.0, 3/2*np.pi, N, endpoint=True)
  dx = x[1]-x[0]

  # Fixing the first row for Neumann, in this case, would yield a singular matrix!
  #A[0, :2] = np.array([-1, 1]) # first order approximation of the derivative
  # We thus need to build a smaller matrix and then add condition u[0]=u[1]
  # It corresponds to the second row becoming [1, -1, 0, ... 0]
  # Construction of the matrix (N-2xN-2)
  A = 2*np.eye(N-2) - np.diag(np.ones(N-3),1) - np.diag(np.ones(N-3),-1)
  print(A)
  A[0, 0] = 1

  # Construction of the RHS
  rhs = dx**2*g(x[1:N-1])
  print(rhs)
  # Fixing the first row for Neumann
  # rhs[0] = 0

  # Solution of the linear system (Au=g)
  u_1N = np.linalg.solve(A, rhs)
  print(u_1N)

  u = np.zeros(N-1)
  print(u)

  u[0] = u_1N[0] # Fixing the first row for Neumann
  u[1:] = u_1N
  print(u)

  return x, u

"""Solution"""

g = lambda x: np.cos(x)
u_ex = lambda x: np.cos(x)

#N_vec = [40, 80, 160, 320]
N_vec = [10]
err_vec1_W = np.zeros(len(N_vec))
err_vec1_R = np.zeros(len(N_vec))
#err_vec2 = np.zeros(len(N_vec))

for ii, N in enumerate(N_vec):
  x1_W, u1_W = solve_poisson_nd_order1_W(g, N) # wrong first order approx
  x1_R, u1_R = solve_poisson_nd_order1_R(g, N) # right first order approx
  #x2, u2 = solve_poisson_nd(g, N)              # second order approx
  err_vec1_W[ii] = np.max(np.abs(u_ex(x1_W[1:N-1]) - u1_W[1:])) # wrong first order error
  err_vec1_R[ii] = np.max(np.abs(u_ex(x1_R[1:N-1]) - u1_R[1:])) # right first order error
  #err_vec2[ii] = np.max(np.abs(u_ex(x2[1:N-1]) - u2[1:]))       # second order error

fig, ax = plt.subplots()
ax.plot(x1_W[:N-1], u1_W, 'ro')
ax.plot(x1_W[:N-1], u_ex(x1_W[:N-1]), 'b')
ax.plot(x1_R[:N-1], u1_R, 'g*')
ax.plot(x1_R[:N-1], u_ex(x1_R[:N-1]), 'y')
#ax.plot(x2[:N-1], u2, 'g*')
#ax.plot(x2[:N-1], u_ex(x2[:N-1]), 'y')
print('errors first order wrong = ', err_vec1_W)
print('errors first order right = ', err_vec1_R)
#print('errors second order= ', err_vec2)

fig, ax = plt.subplots()
ax.loglog(N_vec, err_vec1_W, '*')
ax.loglog(N_vec, err_vec1_R, 'x')
#ax.loglog(N_vec, err_vec2, 'o')
ax.loglog(N_vec, 10/np.array(N_vec)**2, '-')
ax.loglog(N_vec, 1/np.array(N_vec), '-')

"""# Laboratory Session 2 - Elliptic Problem 1D

## Functions

Other Useful Functions for matrix representation
"""

# TO BE USED AFTER HAVING ASSEMBLED MATRIX a -> FireDrake uses automatically sparse matrices
A = assemble(a) # esplicitely assemble system matrix, taking as argument bilinear form
#A # will show a mess
#A.M # will print decent numbers
#print('Size of matrix A as stored by Firedrake = ', A.M.nbytes)
#print('Size of matrix A in dense format = ', A.M.values.nbytes)
A.M.values # dense representation

"""Function to solve 1D, Dirichlet, Poisson Type Problem"""

def poisson_DIRICHLET_1D(f, N, grade, p_type, automatic, conditionals):
  # One Dimension, Poisson, Dirichlet Boundary Conditions

  # INPUT: Forcing Term f as Lambda Function, Mesh elements N, Polimial Grade grade,
  # 'P' 'Lagrange' p_type,
  # Logical Value (True/False) for enforcing non homogeneous solutions
  # automatic,
  # Logical Value (True/False) for treatment of conditionals functions
  # conditionals
  print('Automatic set to:',automatic)
  print('Presence of conditionals:',conditionals)

  # DISCRETIZATION
  mesh = UnitIntervalMesh(N)
  x = SpatialCoordinate(mesh)
  V = FunctionSpace(mesh, p_type, grade)

  # LIFTING FUNCTION
  R = 1-x[0]

  # DIRICHLET BCS
  if automatic == True:
    bc = DirichletBC(V, R, 'on_boundary')
  else:
    bc = DirichletBC(V, fd.Constant(0.), 'on_boundary')

  # PROBLEM
  u = TrialFunction(V)
  v = TestFunction(V)

  # CONDITIONALS
  if conditionals == True:
    # WRITE EXPRESSION HERE, mind the dimension
    #f = fd.conditional(x[0]<1/2, 1, 0)
    f = conditional(x[0]<1/2, fd.sin(2*np.pi*x[0]), 0)
    L = f * v * dx
  else:
    L = f(x[0]) * v * dx

  a = dot(grad(u), grad(v)) * dx

  # SOLUTION
  if automatic == True:
    u_h = Function(V)
    solve(a==L, u_h, bcs=bc)
  else:
    u_tilde = Function(V)
    solve(a==L, u_tilde, bcs=bc)
    u_h = project(u_tilde + R, V)
  # solve(a==L, u_h, (bc0, bc1))


  # ERROR, TO BE MODIFIED EACH TIME
  # WRITE EXPRESSION HERE, mind the dimension
  # u_ex_fd = 1/(4*np.pi**2) * sin(2*np.pi*x[0]) # Exact Solution - FD, only after defining x in FD
  # u_ex_fd = conditional(x[0]<1/2, 3/8*x[0] - 1/2*x[0]**2 , 1/8*(1-x[0]))
  #u_ex_fd = conditional(x[0]<1/2,
   #                     1/(4*np.pi**2) * sin(2*np.pi*x[0]) + 1/(4*np.pi)*x[0],
   #                     1/(4*np.pi) * (1 - x[0]))
  u_ex_fd = exp(-x[0])*(1-x[0])
  if conditionals == True:
    H1error = errornorm(u_ex_fd, u_h, norm_type='H1')
    L2error = errornorm(u_ex_fd, u_h, norm_type='L2')
  else:
    H1error = errornorm(u_ex_fd, u_h, norm_type='H1')
    L2error = errornorm(u_ex_fd, u_h, norm_type='L2')

  # OUTPUT: Elements for plot mesh x V3, solution, errors
  return mesh, x, u_h, H1error, L2error

"""Function To Plot 1D Solutions"""

def plot1D(u_h, u_ex_lambda, u_ex_fd, N, V3, labelMPL, labelFD):
  # Input: Firedrake Solution u_h, Lambda Function u_ex, Mesh elements N,
  # labelMPL = 1 MPL Exact solution required, labelFD = 1 FD Exact solution required

  fig, ax = plt.subplots()

  # FE SOLUTION - FD
  fdplt.plot(u_h, axes=ax, color='k',label='$u_h$')

  # EXACT SOLUTION - MP
  if labelMPL == 1:
    x_fine = np.linspace(0, 1, 25) # BOUNDARIES COULD VARY
    ax.plot(x_fine, u_ex_lambda(x_fine),'*',color='b',label='$u_{ex PLT}$')

  # EXACT SOLUTION - FD
  if labelFD == 1:
    fdplt.plot(project(u_ex_fd, V3), axes=ax, color='r',label='$u_{ex FD}$')

  ax.legend()
  return

"""## Exercise 1"""

grade = 1
p_type = 'P' # Lagrange, P
automatic = True
conditionals = False

f = lambda x: sin(2*np.pi*x) # Forcing Term, FD

mesh, x, u_h, H1error, L2error = poisson_DIRICHLET_1D(f, N, grade, p_type, automatic, conditionals)

# PLOT
V3 = FunctionSpace(mesh, 'Lagrange', 3)
u_ex_fd = 1/(4*np.pi**2) * sin(2*np.pi*x[0]) # Exact Solution - FD, only after defining x in FD
u_ex_lambda = lambda x: 1/(4*np.pi**2) * np.sin(2*np.pi*x) # Exact Solution - MPL

labelMPL = True
labelFD = True
plot1D(u_h, u_ex_lambda, u_ex_fd, N, V3, labelMPL, labelFD)

errvecH1 = []
errvecL2 = []

Nvec = np.array([10, 20, 50])
for N in Nvec:
  mesh, x, u_h, H1error, L2error = poisson_DIRICHLET_1D(f, N, grade, p_type, automatic, conditionals) # SOLVING FUNCTION
  errvecH1.append(H1error)
  errvecL2.append(L2error)

# Estimate the order of convergence
p_H1 = (np.log(errvecH1[0]) - np.log(errvecH1[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
p_L2 = (np.log(errvecL2[0]) - np.log(errvecL2[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
print('Order of convergence in H1 norm = ', p_H1)
print('Order of convergence in L2 norm = ', p_L2)
# The solution is in H1 but not in H2, thus the convergence rate

fig, ax = plt.subplots()
ax.loglog(Nvec, errvecH1, 'x') # CONVERGENCE OF ORDER 1
ax.loglog(Nvec, 1/Nvec,color='r', label='Order 1')
ax.loglog(Nvec, errvecL2, 'o') # CONVERGENCE OF ORDER 2
ax.loglog(Nvec, 1/Nvec**2,color='b', label='Order 2')
ax.legend()

"""## Exercise 3




"""

N = 10
grade = 2
p_type = 'Lagrange' # Lagrange, P
automatic = True
conditionals = True

f = lambda x: Constant(0.) # Face Forcing Term, Only to pass to the function this parameter
#f = fd.conditional(x[0]<1/2, 1, 0) # True Forcing Term Conditional

mesh, x, u_h, H1error, L2error = poisson_DIRICHLET_1D(f, N, grade, p_type, automatic, conditionals)

# PLOT
V3 = FunctionSpace(mesh, 'Lagrange', 3)
u_ex_fd = conditional(x[0]<1/2, 3/8*x[0] - 1/2*x[0]**2 , 1/8*(1-x[0])) # FD = UFL
u_ex_lambda = lambda x: (3/8*x - 1/2*x**2)*(x<=1/2) + (1/8*(1 - x))*(x>1/2) # Exact Solution - MPL

labelMPL = True
labelFD = True
plot1D(u_h, u_ex_lambda, u_ex_fd, N, V3, labelMPL, labelFD)

errvecH1 = []
errvecL2 = []

#Nvec = np.array([10, 100, 500])
#Nvec = np.arange(11, 40, 2) # odd
Nvec = np.arange(10, 40, 2) # even

for N in Nvec:
  mesh, x, u_h, H1error, L2error = poisson_DIRICHLET_1D(f, N, grade, p_type, automatic, conditionals) # SOLVING FUNCTION
  errvecH1.append(H1error)
  errvecL2.append(L2error)

# Estimate the order of convergence
p_H1 = (np.log(errvecH1[0]) - np.log(errvecH1[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
p_L2 = (np.log(errvecL2[0]) - np.log(errvecL2[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
print('Order of convergence in H1 norm = ', p_H1)
print('Order of convergence in L2 norm = ', p_L2)
# The solution is in H1 but not in H2, thus the convergence rate

fig, ax = plt.subplots()
ax.loglog(Nvec, errvecH1) # CONVERGENCE OF ORDER 1
#ax.loglog(Nvec, 1/Nvec, color='r', label='Order 1')
ax.loglog(Nvec, errvecL2) # CONVERGENCE OF ORDER 2
#ax.loglog(Nvec, 1/Nvec**2, color='b', label='Order 2')
ax.legend()

"""## Exercise 4"""

N = 10
grade = 2
p_type = 'Lagrange' # Lagrange, P
automatic = True
conditionals = True

f = lambda x: Constant(0.) # Face Forcing Term, Only to pass to the function this parameter
#f = fd.conditional(x[0]<1/2, fd.sin(2*np.pi*x[0]), 0) # True Forcing Term Conditional

mesh, x, u_h, H1error, L2error = poisson_DIRICHLET_1D(f, N, grade, p_type, automatic, conditionals)

# PLOT
V3 = FunctionSpace(mesh, 'Lagrange', 3)
u_ex_fd = conditional(x[0]<1/2,
                      1/(4*np.pi**2) * sin(2*np.pi*x[0]) + 1/(4*np.pi)*x[0],
                      1/(4*np.pi) * (1 - x[0]))
u_ex_lambda = lambda x: (1/(4*np.pi**2) * np.sin(2*np.pi*x) + 1/(4*np.pi)*x)*(x<=1/2) + (1/(4*np.pi) * (1 - x))*(x>1/2)
# Exact Solution - MPL

labelMPL = True
labelFD = True
plot1D(u_h, u_ex_lambda, u_ex_fd, N, V3, labelMPL, labelFD)

errvecH1 = []
errvecL2 = []

#Nvec = np.array([10, 100, 500])
Nvec = np.arange(11, 40, 2) # odd
#Nvec = np.arange(10, 40, 2) # even

for N in Nvec:
  mesh, x, u_h, H1error, L2error = poisson_DIRICHLET_1D(f, N, grade, p_type, automatic, conditionals) # SOLVING FUNCTION
  errvecH1.append(H1error)
  errvecL2.append(L2error)

# Estimate the order of convergence
p_H1 = (np.log(errvecH1[0]) - np.log(errvecH1[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
p_L2 = (np.log(errvecL2[0]) - np.log(errvecL2[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
print('Order of convergence in H1 norm = ', p_H1)
print('Order of convergence in L2 norm = ', p_L2)
# The solution is in H1 but not in H2, thus the convergence rate

fig, ax = plt.subplots()
ax.loglog(Nvec, errvecH1, 'x') # CONVERGENCE OF ORDER 1
#ax.loglog(Nvec, 1/Nvec, color='r', label='Order 1')
ax.loglog(Nvec, errvecL2, 'o') # CONVERGENCE OF ORDER 2
#ax.loglog(Nvec, 1/Nvec**2, color='b', label='Order 2')
ax.legend()

"""## Exercise 5

Problem statement
"""

N = 10
grade = 2
p_type = 'Lagrange' # Lagrange, P
automatic = False
conditionals = False

f = lambda x: exp(-x)*(x-3)
mesh, x, u_h, H1error, L2error = poisson_DIRICHLET_1D(f, N, grade, p_type, automatic, conditionals)

# PLOT
V3 = FunctionSpace(mesh, 'Lagrange', 3)
u_ex_fd = exp(-x[0])*(1-x[0]) # FD Object
u_ex_lambda = lambda x: np.exp(-x)*(1-x) # Non FD Object
# Exact Solution - MPL

labelMPL = True
labelFD = True
plot1D(u_h, u_ex_lambda, u_ex_fd, N, V3, labelMPL, labelFD)

errvecH1 = []
errvecL2 = []

#Nvec = np.array([10, 100, 500])
Nvec = np.arange(11, 40, 2) # odd
#Nvec = np.arange(10, 40, 2) # even

for N in Nvec:
  mesh, x, u_h, H1error, L2error = poisson_DIRICHLET_1D(f, N, grade, p_type, automatic, conditionals) # SOLVING FUNCTION
  errvecH1.append(H1error)
  errvecL2.append(L2error)

# Estimate the order of convergence
p_H1 = (np.log(errvecH1[0]) - np.log(errvecH1[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
p_L2 = (np.log(errvecL2[0]) - np.log(errvecL2[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
print('Order of convergence in H1 norm = ', p_H1)
print('Order of convergence in L2 norm = ', p_L2)
# The solution is in H1 but not in H2, thus the convergence rate

fig, ax = plt.subplots()
ax.loglog(Nvec, errvecH1, 'x') # CONVERGENCE OF ORDER 1
#ax.loglog(Nvec, 1/Nvec, color='r', label='Order 1')
ax.loglog(Nvec, errvecL2, 'o') # CONVERGENCE OF ORDER 2
#ax.loglog(Nvec, 1/Nvec**2, color='b', label='Order 2')
ax.legend()

"""# Laboratory Session 3 - Elliptic Problem 2D

Exercise 1:  DIRICHLET BCS are enfornced as Lab.2, NEUMANN are enforced in the variational formulation, CONFROTING DIFFERENT TYPE OF SOLVERS NUMBER OF ITERATIONS AND COMPUTUATIONAL TIME
"""

# fig, ax = plt.subplots()     # to recognize every part of the boundary
  # fdplt.triplot(mesh, axes=ax) # 1, 2 -> Dirichlet boundary 3 -> Neumann boundary
  # ax.legend()                  # 4 -> Robin boundary

def solver2D(N):

  # DISCRETIZATION
  mesh = UnitSquareMesh(N, N)
  V = FunctionSpace(mesh, 'P', 1)
  x = SpatialCoordinate(mesh)

  # DIRICHLET BCS
  gD = Constant(0.)
  bc = DirichletBC(V, gD, ()) # PURE DIRICHLET NON HOM
  #bc = DirichletBC(V, Constant(0.0), (1, 2)) # DIRICHLET ON 1 and 2 boundary

  # VARIATIONAL FORMULATION
  u = TrialFunction(V)
  v = TestFunction(V)

  # PROBLEM DATA
  f = Constant(1.)
  k = as_matrix([[-1, 0],[0, -2]])

  # dx stays for integrated in the domain, ds(i) stays for the boundary i,

  # a = k * dot(grad(u), grad(v)) * dx  +  alpha * u * v * ds(4)
  # L = f * v * dx  - gN * v * ds(3)  +  alpha * uR * v * ds(4)

  a = dot(grad(u), grad(v)) * dx
  L = f*v*dx

  # SOLUTION

  u_h = Function(V)
  solve(a==L, u_h, bc0)

  return u_h, mesh

# Compare the performances in terms of iterations and time
# by using no preconditioner ('none'), or amg ('gamg')
# iterative methods: 'cg' or 'gmres'
N = 10
g_D = Constant(0.)

parameters = {'ksp_type': 'gmres', 'pc_type': 'ilu'} # Default setting
u_h, mesh, t_default, iters = solver2D(N, g_D, parameters)
print('time = ', t_default)
print('number of iterations = ', iters)

parameters = {'ksp_type': 'cg', 'pc_type': 'none'}
u_h, mesh, t_default, iters = solver2D(N, g_D, parameters)
print('time = ', t_default)
print('number of iterations = ', iters)

parameters = {'ksp_type': 'cg', 'pc_type': 'gamg'}
u_h, mesh, t_default, iters = solver2D(N, g_D, parameters)
print('time = ', t_default)
print('number of iterations = ', iters)

# PLOT SOLUTION
fig, ax = plt.subplots() # being 1 the free stream temperature
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q)

# PLOT ERROR
x = SpatialCoordinate(mesh)
u_ex = sin(pi*x[0]) * sin(pi*x[1])
Vaux = FunctionSpace(mesh, 'Lagrange', 3) # SHOULD BE HIGHER ORDER SPACE

fig, ax = plt.subplots()
q = fdplt.tripcolor(project(u_ex - u_h, Vaux), axes=ax)
fig.colorbar(q)

"""# Laboratory Session 4 - Mesh and Stiffness Matrix Manual Generation"""

!apt-get install gmsh
!pip3 install pygmsh

import pygmsh
import matplotlib.pyplot as plt
from matplotlib.path import Path
import numpy as np

# Build the mesh manually
# 1D -> use a Numpy array (linspace)
# 2D -> Gmsh
# Mesh given by two matrices: COORDINATE M, row -> coordinates each node
#                             CONNECTIVITY M, row -> nodes of each element
# C[ii] = [3, 7, 9], then C[ii, 0] = 3, C[ii, 1] = 7, and C[ii, 2] = 9
# This means that the first node of the ii-th element is the 3rd node globally,
# the second node is the 7th node globally, and so on.

with pygmsh.geo.Geometry() as geom:
    h = 0.1 # MESH SIZE
    # DEFININING POINTS (you can build any geometry)
    #p1 = geom.add_point([0.0, 0.0], h)
    #p2 = geom.add_point([1.0, -0.2], h)
    #p3 = geom.add_point([1.1, 1.2], h)
    #p4 = geom.add_point([0.1, 0.7], h)
    p1 = geom.add_point([0.0, 0.0], h) # COORDINATES OF THE POINTS AND REQUIRED
    p2 = geom.add_point([1.0, 0.0], h) # MESH SIZE
    p3 = geom.add_point([1.0, 1.0], h)
    p4 = geom.add_point([0.0, 1.0], h)
    # DEFINING LINES (edges connecting the points)
    l1 = geom.add_line(p1, p2)
    l2 = geom.add_line(p2, p3)
    l3 = geom.add_line(p3, p4)
    l4 = geom.add_line(p4, p1)
    boundary = geom.add_curve_loop([l1, l2, l3, l4]) # DEFINE LINES ORDER USING A LIST
    # surface, CREATING BOUNDARY SURFACE
    pl = geom.add_plane_surface(boundary) # CREATING DOMAIN
    # boundary tags, SPECIFING BOUNDARY TYPE
    geom.add_physical([l2, l3], 'dirichlet_boundary')
    geom.add_physical([l1, l4], 'neumann_boundary')
    mesh = geom.generate_mesh() # GENERATING MESH

# COORDINATE MATRIX, LIST OF ALL THE NODES, each row contains coordinates of each node of the mesh in the domain
x = mesh.points[:,:-1] # nodes, ignoring the z coordinate (-1) (rows, cols)
# all rows all columns a part from last column (-1) each line one node, first column x, second column y, ecc

# CONNECTIVITY MATRIX, there is no order in the C Matrix
C = mesh.cells_dict['triangle'] # INSIDE DOMAIN connectivity of the mash (triangles -> 3 indices integers for each line of the matrix)
C_lines = mesh.cells_dict['line'] # DOMAIN BOUNDARY connectivity of the boundary edges (segments -> 2 indices integers for each line of the matrix)

# INDICES of ELEMENTS/EDGES -> INDEX EXTRACTION (THE INDEX IS THE POSITION,
# ON A LIST OF EACH ELEMENT)
# EXTRACTING INDICES OF THE EDGES OF EACH TYPE OF BOUNDARY
# UNDERSTAND WHERE TO IMPOSE THE BOUNDARY CONDITIONS
dir_indices_elements = mesh.cell_sets['dirichlet_boundary'][0] # indices of ELEMENTS of dirichlet boundaries
neu_indices_elements = mesh.cell_sets['neumann_boundary'][0]

# INDICES of NODES/POINTS
# USE EXTRACTED INDEX OF DIRICHLET EDGES TO SELECT THE DIRICHLET NODES
# FROM THE DOMAIN BOUNDARY
dir_indices_nodes = C_lines[dir_indices_elements] # edges of the dirichlet boundary
neu_indices_nodes = C_lines[neu_indices_elements] # edges of the neuman boundary

# Unique will take care of taking only once each node
dir_pt_indices = np.unique(dir_indices_nodes.flatten()) # matrix 2 columns, rows = dir edges

x_dir = x[dir_pt_indices] # from the

fig, ax = plt.subplots()
ax.triplot(x[:,0], x[:,1], C, color='k') # plot triangulation
ax.plot(x_dir[:,0], x_dir[:,1], 'bo') # plot Dirichlet points
ax.set_aspect('equal')

N_nodes = x.shape[0]
N_elements = C.shape[0]

print(N_nodes)
print(N_elements)

def assemble(x, C, f):
    # taking coordinates, connectivity and rhs fun and builds A and B
    '''
    construct the Grad*Grad stiffness matrix and rhs vector
    corresponding to mesh (P,T) and load function f
    '''
    # 1) FOR ALL THE ELEMENTS:
    #        2) FOR ALL THE NODES IN EACH ELEMENT:
    #                 3) Compute the integrals in each element

    # 1) Loop over the elements -> compute number of elements
    # so the number of rows of the connectivity table
    #N_elements = len(C) # or
    N_elements = C.shape[0] # DICTATING number of integrals

    # 2) Loop over the elements -> compute number of nodes
    # Number of nodes -> number of rows of the coordinate table
    N_nodes = x.shape[0] # NUMBER OF UNKNOWNS (the unknowns are the nodal values)

    A = np.zeros((N_nodes, N_nodes)) # NUMBER OF UNKNOWN, DISCATES the solving system
    b = np.zeros(N_nodes)          # dimensions

    # 3.A) ASSEMBLING STIFFNESS MATRIX
    G = np.array(((-1, 1, 0),  # Gradients of shape functions in the reference plane
                  (-1, 0, 1))) # Same for all the elements

    for ii in range(N_elements):
      # 3.B) COMPUTE MATRIX B, ITS INVERSE, ITS DETERMINANT
      # TO COMPUTE MATRIX B, the nodes (x1 x2 x3) composing the triangular element had to be known
      # C Connectivity Matrix, in each row three columns, the three nodes composing the triangular element
      # C[ii,...] -> selecting the nodes 1 2 and 3 of the ii element of connectivity table
      # x coordinate matrix, in each row two columns, the two coordinates of the node
      # x[C[ii, 0]] -> selecting the two coordinates of the nodes 1 2 and 3
      x0 = x[C[ii, 0]]
      x1 = x[C[ii, 1]]
      x2 = x[C[ii, 2]]
      B = np.array(((x1[0] - x0[0], x2[0] - x0[0]),
                    (x1[1] - x0[1], x2[1] - x0[1])))
      J = np.linalg.det(B)
      invB = np.linalg.inv(B)

      # 3.C) COMPUTE LOCAL STIFFNESS MATRIX
      A_loc = 0.5 * J * G.T @ invB @ invB.T @ G # @ matrix multiplication
      # * scalar multiplication

      # 3.D) Global matrix update
      for jj in range(3):
        for kk in range(3):
          A[C[ii, jj], C[ii, kk]] += A_loc[jj, kk]
          # for each triangle, taking all nodes, putting the A_local of each node in the
          # corresponding place in the A_global
          # Example
          # C[ii,jj] selecting jj-th node in the ii-th element, Ex -> Node 3 globally
          # C[ii,kk] selecting kk-th node in the same element, Ex -> Node 6 globally
          #  A[C[ii, jj], C[ii, kk]] access the row 3, column 6 of A, putting there
          # the corrispondent value

      # RHS
      xb = (x0 + x1 + x2)/3 # Triangle Baricenter
      b_loc = 1/6 * J * f(xb[0], xb[1]) # Local contribution to b_s
      # xb[0] x, xb[0] y

      # Global vector update
      # For element ii, for each one of its three nodes sum the local stif matrix
      for jj in range(3):
        b[C[ii, jj]] += b_loc

    return A, b

def neumann_rhs(x, neu_edges, g_N):
    """
    Construct the contribution of the Neumann condition to the RHS
    """
    N_nodes = x.shape[0] # Same shape of before
    b_N = np.zeros(N_nodes) # Initializing, same dimension of RHS

    N_neu_edges = neu_edges.shape[0] # Number of Neumann edges
    # one integral for each Neumann boundary element

    for ii in range(N_neu_edges):
      # Now we are on the boundary, the element from triangular becomes linear
      # neu_edges is the connectivity matrix with two columns instead of three
      x0 = x[neu_edges[ii, 0]]
      x1 = x[neu_edges[ii, 1]]

      E = np.linalg.norm(x1 - x0) # length of the element
      # Composing local RHS
      xb = (x0 + x1)/2 # Same as before, just with only two nodes
      b_loc = 0.5 *g_N(xb[0], xb[1]) * E

      for jj in range(2):
        b_N[neu_edges[ii, jj]] += b_loc

    return b_N

def apply_bc(A, b, g_D, x, dir_pt_indices):
    """
    Apply Dirichlet conditions to matrix A and rhs vector b
    """
    # Substitute all rows i corresponding to Dirichlet nodes with boundary conditions
    # dir_pt_indices -> indices of Dirichlet nodes
    for ind in dir_pt_indices:
      # Effects of Dirichlet BCS
      A[ind, :] = 0 # all row to zero, the corresponding equation is not valid anymore
      A[ind, ind] = 1 # diagonal value to zero
      b[ind] = g_D(x[ind, 0], x[ind, 1]) # corresponding RHS value is fixed to boundary value
      # x coordinate matrix, x[ind,...] coordinates of the node two values,
      # x[ind,0] first coordinate (x),  x[ind,0] second coordinate (y)
      # g_D(x[ind, 0], x[ind, 1]) value of the dirichlet bcs function in the coordiantes of that node

    return A, b

f = lambda x, y: 4 - 2*(x**2 + y**2) # RHS
g_N = lambda x, y: 0 # NEUMANN BCS
g_D = lambda x, y: 0 # DIRICHLET BCS

# TAKING: COORDINATE, CONNECTIVITY AND RHS FUNCTION -> BUILD MATRICES A and B
A, b = assemble(x, C, f)
# TAKING: COORDINATE, CONNECTIVITY of Neumann Edges AND Neumann BCS -> Build RHS of Neumann conditions
b_N = neumann_rhs(x, neu_indices_nodes, g_N)
# BUILDING RHS
b = b + b_N
# APPLYING DIRICHLET BCS
A_bc, b_bc = apply_bc(A, b, g_D, x, dir_pt_indices) # indices of dirichlet nodes

# Solve the system
u = np.linalg.solve(A_bc, b_bc)

# Plot the solution
fig, ax = plt.subplots()
q = ax.tricontourf(x[:,0], x[:,1], u)
plt.colorbar(q)

u_ex = lambda x, y: (1 - x**2) * (1 - y**2)

# Plot the exact solution
fig, ax = plt.subplots()
q = ax.tricontourf(x[:,0], x[:,1], u_ex(x[:,0], x[:,1]))
plt.colorbar(q)

"""# Laboratory Session 5 - Parabolic Problem

Exercises, Paraview Implementation, Solver Comparison
"""

try:
    import firedrake
except ImportError:
    !wget "https://fem-on-colab.github.io/releases/firedrake-install-real.sh" -O "/tmp/firedrake-install.sh" && bash "/tmp/firedrake-install.sh"
    import firedrake

from firedrake import *
import firedrake.pyplot as fdplt
import matplotlib.pyplot as plt
from time import perf_counter

from firedrake.output import VTKFile #exporting for Paraview visualization

"""## Exercise 1: Solution and PARAVIEW Implementation

Function: Dirichlet
"""

def parabolic_Solver(dt, theta, n, solver_parameters):

  # Errors
  errL2 = 0
  errH1 = 0

  # Space Discretizatin
  #n = 10
  mesh = UnitSquareMesh(n, n, diagonal='crossed')
  V = FunctionSpace(mesh, 'P', 2)
  x, y = SpatialCoordinate(mesh)

  # TIME DISCRETIZATION
  T = 1.   # TOTAL TIME
  #dt = 1.  # TIME STEP
  #theta = Constant(0.5) # THETA METHOD TUNING

  # Forcing term
  f_fun = lambda t: (pi/2*cos(pi*t) + pi**2*sin(pi*t)) * sin(pi*x) * sin(pi*y) # VARYING IN TIME
  # Exact solution
  # LAMBDA OF t, x, y not considered
  u_ex = lambda t: 1 + 0.5 * sin(pi*t) * sin(pi*x) * sin(pi*y) # VARYING IN TIME

  # Boundary condition
  g = Constant(1.0)
  bc = DirichletBC(V, g, "on_boundary")

  # INITIAL CONDITION
  t = 0
  u_old = project(u_ex(t), V) # THE EXACT SOLUTION AT t=0, x, y not considered

  # Variational formulation
  u = TrialFunction(V)
  v = TestFunction(V)

  # SOLUTION
  u_h = Function(V, name='Temperature') # Name (Paraview visualization)
  u_h.assign(u_old) # THE INITIAL CONDITION OF THE SOLUTION u_h IS THE VALUE OF u_old, THE SOLUTION AT THE PREVIOUS TIME STEP

  # ASSEMBLING NOT TIME VARYING SYSTEM TERMS
  a = 1/dt * u * v * dx + theta * dot(grad(u), grad(v)) * dx
  A = assemble(a, bcs=bc)

  start_time = perf_counter()

  # SOLVER PARAMETERS
  solver = LinearSolver(A,
                      solver_parameters=solver_parameters)
  #solver = LinearSolver(A,
  #                    solver_parameters={"ksp_type": "preonly",
  #                    "pc_type": "lu"})
  # solver = LinearSolver(A,
  #                      solver_parameters={"ksp_type": "cg",
  #                      "pc_type": "ilu"}) # ILU
  # solver = LinearSolver(A,
  #                      solver_parameters={"ksp_type": "cg",
  #                      "pc_type": "gamg"}) # AMG

  outfile = VTKFile('results/Heat-1.pvd') # Output file (Paraview visualization)
  outfile.write(u_h, time=0)

  # COMPUTING SOLUTION FOR EACH TIME STEP
  while t<T:
    # TIME PARAMETERS
    t_old = t
    t += dt
    #print('t = ', t)

    # ASSEMBLING TIME VARYING SYSTEM PART, COMPUTING THE SOLUTION FOR THIS TIME STEP
    L = ( 1/dt * u_old * v * dx - (1-theta) * (dot(grad(u_old), grad(v)) * dx)
         + theta * f_fun(t) * v * dx + (1-theta) * (f_fun(t_old) * v * dx) )
    b = assemble(L, bcs=bc)
    solver.solve(u_h, b)

    # INITIAL CONDITIONS UPGRADE
    u_old = u_h
    outfile.write(u_h, time=t)

    # Compute the error
    errL2 = max(errL2, errornorm(u_ex(t), u_h, 'L2'))
    errH1 = max(errH1, errornorm(u_ex(t), u_h, 'H1'))

  exec_time = perf_counter() - start_time

  return(mesh, u_h, errH1, errL2, exec_time)

"""Point 3 Space Discretization Convergence"""

errvecH1 = []
errvecL2 = []
# first value to se convergence with N=40 dt = 0.05
dt = 0.05
theta = 0.5
solver_parameters={"ksp_type": "preonly",
                      "pc_type": "lu"}

Nvec = np.array([5, 10, 20, 40])
for n in Nvec:
  mesh, u_h, H1error, L2error, exec_time = parabolic_Solver(dt, theta, n, solver_parameters)
  errvecH1.append(H1error)
  errvecL2.append(L2error)

# Estimate the order of convergence
p_H1 = (np.log(errvecH1[0]) - np.log(errvecH1[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
p_L2 = (np.log(errvecL2[0]) - np.log(errvecL2[-1]))/(np.log(Nvec[-1]) - np.log(Nvec[0]))
print('Order of convergence in H1 norm = ', p_H1)
print('Order of convergence in L2 norm = ', p_L2)
# The solution is in H1 but not in H2, thus the convergence rate

fig, ax = plt.subplots()
ax.loglog(Nvec, errvecH1, 'x', label='Norm H1') # NORM H1
ax.loglog(Nvec, 1/Nvec,color='r', label='Order 1') # CONVERGENCE OF ORDER 1
ax.loglog(Nvec, errvecL2, 'o', label='Norm L2') # NORM L2
ax.loglog(Nvec, 1/Nvec**2,color='b', label='Order 2') # CONVERGENCE OF ORDER 2
ax.legend()

fig, ax = plt.subplots()
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q)

# USING P=1 POLYNOMIALS, CONVERGENCE SHOULD BE ORDER 2 (P+1) FOR L2 AND 1 (P) FOR H1

# PLOT ERROR
x = SpatialCoordinate(mesh)
u_ex = 1 + 0.5 * sin(pi) * sin(pi*x[0]) * sin(pi*x[1]) # SOLUTION FOR t=1
Vaux = FunctionSpace(mesh, 'Lagrange', 3) # SHOULD BE HIGHER ORDER SPACE

fig, ax = plt.subplots()
q = fdplt.tripcolor(project(u_ex - u_h, Vaux), axes=ax)
fig.colorbar(q)

"""Point 4 Time Discretization Converegence"""

solver_parameters={"ksp_type": "preonly",
                      "pc_type": "lu"}
errvecH1 = []
errvecL2 = []
n = 10
# UNCONDITIONALLY STABLE METHODS FOR ANY dt
theta = Constant(0.5) # CRANK NICHOLSON ORDER OF CONVERGENCE WRT TIME = 2 IN L2 NORM
#theta = Constant(1) # IMPLICIT EULER ORDER OF CONVERGENCE WRT TIME = 2 IN L2 NORM
# CONDITIONALLY STABLE METHODS
# DELTA T < h^2  h=0.1 h^2=0.01
#theta = Constant(0) # CONVERGENCE WRT TIME = 1 IN L2 NORM

Tvec = np.array([1., 0.5, 0.25, 0.125])
for dt in Tvec:
  mesh, u_h, H1error, L2error, exec_time = parabolic_Solver(dt, theta, n, solver_parameters)
  errvecH1.append(H1error)
  errvecL2.append(L2error)

print('error in L^infty((0,T), L^2) = ', L2error)
print('error in L^infty((0,T), H^1)  = ', H1error)
print('Execution time = ', exec_time)

# Estimate the order of convergence
p_H1 = (np.log(errvecH1[0]) - np.log(errvecH1[-1]))/(np.log(Tvec[-1]) - np.log(Tvec[0]))
p_L2 = (np.log(errvecL2[0]) - np.log(errvecL2[-1]))/(np.log(Tvec[-1]) - np.log(Tvec[0]))
print('Order of convergence in H1 norm = ', p_H1)
print('Order of convergence in L2 norm = ', p_L2)
# The solution is in H1 but not in H2, thus the convergence rate

fig, ax = plt.subplots()
ax.loglog(Tvec, errvecH1, 'x', label='Norm H1') # NORM H1
ax.loglog(Tvec, 1/Tvec,color='r', label='Order 1') # CONVERGENCE OF ORDER 1
ax.loglog(Tvec, errvecL2, 'o', label='Norm L2') # NORM L2
ax.loglog(Tvec, 1/Tvec**2,color='b', label='Order 2') # CONVERGENCE OF ORDER 2
ax.legend()

# CRANK NICHOLSON ORDER 2 FOR L2 AND ORDER 1 FOR H1

"""Point 5"""

solver_parameters1={"ksp_type": "preonly",
                      "pc_type": "lu"}
mesh, u_h, errH1, errL2, exec_time_lu = parabolic_Solver(dt, theta, n, solver_parameters)

solver_parameters2={"ksp_type": "cg",
                     "pc_type": "gamg"}
mesh, u_h, errH1, errL2, exec_time_gamg = parabolic_Solver(dt, theta, n, solver_parameters)

print('Execution time = ', exec_time_lu)
print('Execution time = ', exec_time_gamg)

"""## EXERCISE 2

Function: Dirichlet and Neumann
"""

def parabolic_Solver(dt, theta, n, solver_parameters):

  # Errors
  errL2 = 0
  errH1 = 0

  # Space Discretizatin
  #n = 10
  mesh = UnitSquareMesh(n, n, diagonal='crossed')
  V = FunctionSpace(mesh, 'P', 1)
  x, y = SpatialCoordinate(mesh)

  # TIME DISCRETIZATION
  T = 1.   # TOTAL TIME
  #dt = 1.  # TIME STEP
  #theta = Constant(0.5) # THETA METHOD TUNING

  # Forcing term
  f_fun = lambda t: (pi/2*cos(pi*t) + pi**2*sin(pi*t)) * sin(pi*x) * sin(pi*y) # VARYING IN TIME
  # Exact solution
  # LAMBDA OF t, x, y not considered
  u_ex = lambda t: 1 + 0.5 * sin(pi*t) * sin(pi*x) * sin(pi*y) # VARYING IN TIME

  # Dirichlet Boundary condition
  gD = Constant(40.0)
  bc = DirichletBC(V, gD, 1)

  # DATA FOR INITIAL CONDITIONS AND NEUMANN BCS ENFORNCED IN VARIATIONAL FORM
  k = Constant(1.e-2)
  alpha = Constant(1.e-2)
  T = 200.0
  dt = 5.0

  uEnv = Constant(5.0)

  # INITIAL CONDITION
  t = 0
  u_old = project(Constant(20), V)# THE EXACT SOLUTION AT t=0, x, y not considered

  # Variational formulation
  u = TrialFunction(V)
  v = TestFunction(V)

  # SOLUTION
  u_h = Function(V, name='Temperature') # Name (Paraview visualization)
  u_h.assign(u_old) # THE INITIAL CONDITION OF THE SOLUTION u_h IS THE VALUE OF u_old, THE SOLUTION AT THE PREVIOUS TIME STEP

  # ASSEMBLING NOT TIME VARYING SYSTEM TERMS
  a = (u * v / dt + k * dot(grad(u), grad(v))) * dx + alpha * u * v * ds(4)
  A = assemble(a, bcs=bc)

  start_time = perf_counter()

  # SOLVER PARAMETERS
  solver = LinearSolver(A,
                      solver_parameters=solver_parameters)
  #solver = LinearSolver(A,
  #                    solver_parameters={"ksp_type": "preonly",
  #                    "pc_type": "lu"})
  # solver = LinearSolver(A,
  #                      solver_parameters={"ksp_type": "cg",
  #                      "pc_type": "ilu"}) # ILU
  # solver = LinearSolver(A,
  #                      solver_parameters={"ksp_type": "cg",
  #                      "pc_type": "gamg"}) # AMG

  outfile = VTKFile('results/Heat-1.pvd') # Output file (Paraview visualization)
  outfile.write(u_h, time=0)

  # COMPUTING SOLUTION FOR EACH TIME STEP
  while t<T:
    # TIME PARAMETERS
    t_old = t
    t += dt
    #print('t = ', t)

    # ASSEMBLING TIME VARYING SYSTEM PART, COMPUTING THE SOLUTION FOR THIS TIME STEP
    L = u_old * v / dt * dx + alpha * uEnv * v * ds(2)
    b = assemble(L, bcs=bc)
    solver.solve(u_h, b)

    # INITIAL CONDITIONS UPGRADE
    u_old = u_h
    outfile.write(u_h, time=t)

    # Compute the error
    errL2 = max(errL2, errornorm(u_ex(t), u_h, 'L2'))
    errH1 = max(errH1, errornorm(u_ex(t), u_h, 'H1'))

  exec_time = perf_counter() - start_time

  return(mesh, u_h, errH1, errL2, exec_time)

n = 10
theta = 1
dt = 0.1
solver_parameters={"ksp_type": "cg",
                     "pc_type": "gamg"}
mesh, u_h, errH1, errL2, exec_time = parabolic_Solver(dt, theta, n, solver_parameters)

fig, ax = plt.subplots()
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q)

"""# Laboratory Session 6 - Advection Diffusion"""

try:
    import firedrake
except ImportError:
    !wget "https://fem-on-colab.github.io/releases/firedrake-install-real.sh" -O "/tmp/firedrake-install.sh" && bash "/tmp/firedrake-install.sh"
    import firedrake

from firedrake import *
import firedrake.pyplot as fdplt
import matplotlib.pyplot as plt

"""Functions"""

def solve_AD(n, degree, f, u_ex, delta, rho):
  # 1. mesh generation
  mesh = UnitSquareMesh(n, n, 'crossed')

  # 2. definition of finite element space
  V = FunctionSpace(mesh, 'P', degree)
  x = SpatialCoordinate(mesh)
  gD = u_ex(x)
  bc = DirichletBC(V, gD, 'on_boundary')
  #bc = DirichletBC(V, Constant(0.0), (1, 2)) # DIRICHLET ON 1 and 2 boundary

  # 3. assembling bilinear form and linear functionals
  u = TrialFunction(V)
  v = TestFunction(V)

  # PROBLEM DATA
  mu = Constant(1e-3) # PROBLEM DATA
  bx, by = -1.0, -1.0 # ADVECTION VECTOR
  b = Constant((bx, by))
  # b = as_vector([x[1]*(x[1] - 1.0), 0.0])
  f = Constant(0.1) # SOURCE TERM

  # VARIATIONAL FORMULATIONS
  a = (mu * dot(grad(u), grad(v)) + dot(b, grad(u)) * v) * dx
  L = f * v * dx

  # Stabilization term
  h = CellDiameter(mesh)
  bnorm = sqrt(dot(b, b))
  Pe = bnorm*h/(2*mu)
  tau = 0.5*delta*h/bnorm * conditional(Pe/3 > 1, 1, Pe/3)

  # STRONGLY CONSISTENT METHODS: SUPG and GLS, PART 1
  # THIS IS THE SUM OF THE INTEGRALS ON THE ELEMENTS, NOT AN INTEGRAL ON THE ENTIRE
  # DOMAIN, THERE ARE JUMPS IN THE GRADIENTS BETWEEN TWO ELEMENTS
  R = lambda uu: -mu * div(grad(uu)) + dot(b, grad(uu))
  P = lambda uu: rho *(-mu * div(grad(uu))) + dot(b, grad(uu))
  c_strong = tau * R(u) * P(v) * dx # FIRST STABILIZATION TERM LHS
  a_stab = a + c_strong

  # STRONGLY CONSISTENT METHODS: SUPG and GLS, PART 2, ONLY FOR NON HOMOGENEOUS PROBLEMS
  # HOMOGENEOUS IN THIS CASE IS F = 0, NON HOMOGENEOUS F!=0, F IS THE FORCING TERM
  d_strong = f * P(v) * dx # SECOND STABILIZATION RHS
  #L_stab = L + d_strong

  # STREAMLINE DIFFUSION STABILIZATION
  c_stream = tau * dot(b, grad(u)) * dot(b, grad(v)) * dx # STABILIZATION TERM
  # a_stab = a + c_stream

  # 4. solving discrete problem
  u_h = Function(V)
  # solve(a==L, u_h, (bc0, bc1))
  solve(a_stab == L, u_h, bc) # STABILIZED HOMOGENEOUS
  #solve(a_stab == L_stab, u_h, bc) # STABILIZED NON HOMOGENEOUS
  # solve(a == L, u_h, bc) # NOT STABILIZED

  # THE LAPLACIAN IN COMPUTED ELEMENT BY ELEMENT
  # THE GRADIENT FOR P1 ELEMENTS IS CONSTANT, THE DIVERGENCE FOR A CONSTANT IS ZERO,
  # SO THE LAPLACIAN IS ZERO IN EACH ELEMENT.
  # WHAT REMAINS NON ZERO IS THE SAME TERM AS STREAMLINE DIFFUSION STABILIZATION
  # SO USING P1, DEGREE 1 POLINOMIALS, THE SOLUTION IS THE SAME FOR STREAMLINE DIFFUSION METHOD, GLS AND SUPG
  # THE LAPLACIAN IS ZERO FOR EACH ELEMENT
  # WITH P2 THERE IS A DIFFERENCE

  return u_h, mesh

"""## Exercise 1"""

import numpy as np
from sympy import * # Symbolic computations

x, y, mu, bx, by = symbols('x y mu bx by')
b = Matrix([bx, by])
u = (exp((-mu**(-1))*x)-1)/(exp(-mu**(-1))-1) + (exp((-mu**(-1))*y)-1)/(exp(-mu**(-1))-1)

laplacian_u = simplify(diff(u, x, x) + diff(u, y, y))
#print(simplify(laplacian_u))
grad_u = (diff(u, x),diff(u, y))
#print(simplify(grad_u))
f = - mu*laplacian_u + b.dot(grad_u)

f = f.subs({bx : -1, by : -1})
print(simplify(f))

# POINT 2
# THE DIRICHLET CONDITION MUST HOLD FOR ALL EDGES
u_bound1 = u.subs({x: x, y: 0}) # BOTTOM
print(u_bound1)
u_bound2 = u.subs({x: x, y: 1}) # UPPER
print(u_bound2)
u_bound3 = u.subs({x: 0, y: y}) # LEFT
print(u_bound3)
u_bound4 = u.subs({x: 1, y: y}) # RIGHT
print(u_bound4)

# data of the problem
degree = 1 # STARTING WITH P1 ELEMENTS
mu = Constant(1e-2) # PROBLEM DATA

#bx, by = -1.0, -1.0 # ADVECTION VECTOR
#b = Constant((bx, by))
#f = Constant(0) # SOURCE TERM
u_ex = lambda x: (exp(-x[0]/mu) - 1)/(exp(-1/mu) - 1) + (exp(-x[1]/mu) - 1)/(exp(-1/mu) - 1)

# Let us test our code for delta=0 (no stabilization)
# and delta=1 (streamline diffusion stabilization)

n = 10 # small number -> will be unstable
#n = 100 # decent solution, we see the boundary layer

delta = Constant(0.0) # DELTA IS TUNING PARAMETER FOR THE STABILIZATION
u_h, mesh = solve_AD(n, degree, f, u_ex, delta, Constant(0.))

fig, ax = plt.subplots()
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q, fraction=0.045)

delta = Constant(1.0)
u_h, mesh = solve_AD(n, degree, f, u_ex, delta, Constant(0.))

fig, ax = plt.subplots()
q = fdplt.tripcolor(u_h, axes=ax)
#fdplt.triplot(mesh, axes=ax) # plotting also the grid
plt.colorbar(q, fraction=0.045)

# STREAMLINE COMMENTED OUT - STABILIZING WITH STRONGLY CONSISTENT METHODS
# Let us test our code for rho=0 (SUPG) and rho=1 (GLS)
delta = Constant(1.0)
u_h, mesh = solve_AD(n, degree, f, u_ex, delta, Constant(0.)) # SUPG
# SUPG
fig, ax = plt.subplots()
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q, fraction=0.045)
# GLS
u_h, mesh = solve_AD(n, degree, f, u_ex, delta, Constant(1.)) # GLS

fig, ax = plt.subplots()
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q, fraction=0.045)

# Let us now study the accuracy of the methods
"""delta = Constant(0.0) # NO STREAMLINE
for n in [10, 20, 40, 80, 160]:
  u_h, mesh = solve_AD(n, degree, f, u_ex, delta, Constant(0.))
  x = SpatialCoordinate(mesh)
  u_exact = u_ex(x)
  print('n = {:4d}, error L2 = {:.3e}, error H1 = {:3.4f}'.format(n,
  errornorm(u_exact, u_h, 'L2'), errornorm(u_exact, u_h, 'H1')))

delta = Constant(1.0) # STREAMLINE
for n in [10, 20, 40, 80, 160]:
  u_h, mesh = solve_AD(n, degree, f, u_ex, delta, Constant(0.))
  x = SpatialCoordinate(mesh)
  u_exact = u_ex(x)
  print('n = {:4d}, error L2 = {:.3e}, error H1 = {:3.4f}'.format(n,
  errornorm(u_exact, u_h, 'L2'), errornorm(u_exact, u_h, 'H1')))"""

rho = Constant(0.) # SUPG
for n in [10, 20, 40, 80, 160]:
  u_h, mesh = solve_AD(n, degree, f, u_ex, Constant(0.), rho)
  x = SpatialCoordinate(mesh)
  u_exact = u_ex(x)
  print('n = {:4d}, error L2 = {:.3e}, error H1 = {:3.4f}'.format(n,
  errornorm(u_exact, u_h, 'L2'), errornorm(u_exact, u_h, 'H1')))

rho = Constant(1.) # GLS
for n in [10, 20, 40, 80, 160]:
  u_h, mesh = solve_AD(n, degree, f, u_ex, Constant(0.), rho)
  x = SpatialCoordinate(mesh)
  u_exact = u_ex(x)
  print('n = {:4d}, error L2 = {:.3e}, error H1 = {:3.4f}'.format(n,
  errornorm(u_exact, u_h, 'L2'), errornorm(u_exact, u_h, 'H1')))

# THE LAPLACIAN IN COMPUTED ELEMENT BY ELEMENT
# THE GRADIENT FOR P1 ELEMENTS IS CONSTANT, THE DIVERGENCE FOR A CONSTANT IS ZERO,
# SO THE LAPLACIAN IS ZERO IN EACH ELEMENT.
# WHAT REMAINS NON ZERO IS THE SAME TERM AS STREAMLINE DIFFUSION STABILIZATION
# SO USING P1, DEGREE 1 POLINOMIALS, THE SOLUTION IS THE SAME FOR STREAMLINE DIFFUSION METHOD, GLS AND SUPG
# THE LAPLACIAN IS ZERO FOR EACH ELEMENT
# WITH P2 THERE IS A DIFFERENCE

"""Exercise 3"""

degree = 1 # STARTING WITH P1 ELEMENTS
# data of the problem
mu = Constant(1e-3) # PROBLEM DATA
bx, by = 3.0, -1.0 # ADVECTION VECTOR
b = Constant((bx, by))
f = Constant(1.) # SOURCE TERM

n = 10
gD = lambda x: Constant(0.0)
delta = Constant(0.) # NO STABILIZATION AT ALL
rho = Constant(0.)

u_h, mesh = solve_AD(n, degree, f, gD, delta, rho)

fig, ax = plt.subplots()
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q, fraction=0.045)

delta = Constant(1.) # STABILIZED
rho = Constant(1.) # GLS

u_h, mesh = solve_AD(n, degree, f, gD, delta, rho)

fig, ax = plt.subplots()
q = fdplt.tripcolor(u_h, axes=ax)
plt.colorbar(q, fraction=0.045)

"""# Exercise Session 7 - Advection Reaction

Import Firedrake
"""

try:
    import firedrake
except ImportError:
    !wget "https://fem-on-colab.github.io/releases/firedrake-install-real.sh" -O "/tmp/firedrake-install.sh" && bash "/tmp/firedrake-install.sh"
    import firedrake

from firedrake import *
import finat

import matplotlib.pyplot as plt
import firedrake.pyplot as fdplt
import numpy as np

"""Exercise 1"""

N = 10
mesh = UnitSquareMesh(N, N) # mesh

V = FunctionSpace(mesh, 'P', 1) # function space

fig, ax = plt.subplots()
fdplt.triplot(mesh, axes=ax)
ax.legend()
# ctrl shift 7 to comment

bc0 = DirichletBC(V, Constant(0.), (1, 3))
bc1 = DirichletBC(V, Constant(1.), (2, 4))

mu = Constant(1e-4)
sigma = Constant(1.)
f = Constant(0.)

# WITHOUT LUMPING MASS MATRIX
u = TrialFunction(V)
v = TestFunction(V)

a = mu * dot(grad(u), grad(v)) * dx + sigma * u * v * dx
L = f * v * dx

u_h = Function(V)
solve(a==L, u_h, bcs=(bc0, bc1))

fig, ax = plt.subplots()
#q = fdplt.tripcolor(u_h, axes=ax) # WRONG
q = fdplt.tricontourf(u_h, axes=ax) # RIGHT
plt.colorbar(q)

# it is possible tot see that the solution is negative, while it shouldn't be
# that is because of oscillations

# MASS MATRIX LUMPING
M = assemble(u*v*dx).M.values # assembling M

M # looking at M
# row of a matrix + on diag and - el, ok
# all numbers are positive problem, positive solution
# a complitely CONSTANT positive solution is not possible
# M is not all the system, but a part, it M is big with respect to the
# other one -> system will be similar to matrix M

# RULE TO BE ALWAYS FOLLOWED:
#mesh nodes coincides with nodes of integration
# FINAT: QUADRATURE MAKER
# MAKE QUADRATURE: REQUIRING REFERENCE CELL, AND SO DEGREE OF THE POLYNOME
quad_rule = finat.quadrature.make_quadrature(V.finat_element.cell,
                                             1, "KMV")
# write KMV to require the lumping
dxlump = dx(scheme=quad_rule) # DEFINING lumping integration rule on the before defined model

M_lumped = assemble(u*v*dxlump).M.values
M_lumped

np.sum(M, axis=1)
# sum of rows, column 1, of matrix without lumping
# THIS ARE equal to lumped matrix values

np.diag(M_lumped)

bc0 = DirichletBC(V, Constant(0.), (1, 3))
bc1 = DirichletBC(V, Constant(1.), (2, 4))

mu = Constant(1e-4)
sigma = Constant(1.)
f = Constant(0.)

# WITHOUT LUMPING MASS MATRIX
u = TrialFunction(V)
v = TestFunction(V)

quad_rule = finat.quadrature.make_quadrature(V.finat_element.cell,
                                             1, "KMV")
dxlump = dx(scheme=quad_rule)

# ONLY THE REACTION PART IS INTEGRATED WITH LUMPING
a = mu * dot(grad(u), grad(v)) * dx + sigma * u * v * dxlump
L = f * v * dx

u_h = Function(V)
solve(a==L, u_h, bcs=(bc0, bc1))

fig, ax = plt.subplots()
# q = fdplt.tripcolor(u_h, axes=ax)
# q = fdplt.tricontourf(u_h, axes=ax, levels=20) # forcing number of levels plot may get crazy
q = fdplt.tricontourf(u_h, axes=ax)

plt.colorbar(q)

# it is possible tot see that the solution is negative, while it shouldn't be
# that is because of oscillations
# NO OSCILLATION

# no oscillations, no negative values

"""STRANG LEMMA

Integrals are computed in an inexact way, I need to compute them at least as accurate as the order of the finite element method that you are using, to be accurate enought
"""



"""# Laboratory Session 8"""

try:
    import firedrake
except ImportError:
    !wget "https://fem-on-colab.github.io/releases/firedrake-install-real.sh" -O "/tmp/firedrake-install.sh" && bash "/tmp/firedrake-install.sh"
    import firedrake

from firedrake import *

import matplotlib.pyplot as plt
import firedrake.pyplot as fdplt

import numpy as np
from scipy.linalg import null_space

"""Stokes Problem"""

n = 5
mesh = UnitSquareMesh(n, n, diagonal='crossed') # it will be more obvious to see instability

V = VectorFunctionSpace(mesh, 'P', 1) # specify that we want a vector
Q = FunctionSpace(mesh, 'P', 1) # pressure is instead a scalar
# W = MixedFunctionSpace([V, Q])
W = V*Q # same thing, stacking variables in a single vector

W.sub(0) # zero for velocity or pressure, we can work only on the combined workspace
bcs = [DirichletBC(W.sub(0), Constant((1., 0.)), 4),          # part of the boundary interested, defying a constant velocity
       DirichletBC(W.sub(0), Constant((1., 0.)), (1,2,3))]

nullspace = MixedVectorSpaceBasis(
    W, [W.sub(0), VectorSpaceBasis(constant=True)]
) # i want a basis for space, the base need to be constant in a part, and whetever in the other part

f = Constant((0., 0.))

u, p = TrialFunctions(W) # combined function space, two types of trial functions
v, q = TestFunctions(W)

a = inner(grad(u), grad(v))*dx - p*div(v)*dx - q*div(u)*dx
L = dot(f, v)*dx # we need in this case a vector space

w = Function(W)
solve(a==L, w, bcs, nullspace=nullspace)
u_h, ph = w.subfunctions

fig, ax = plt.subplots(2, 1) # grid of 2 rows 1 colums
quiver(u_h, axes=ax[0])
tripcolor(ph, axes=ax[1])
ax[0].set_aspect('equal')
ax[1].set_aspect('equal')

A = assemple(a, bcs=bcs).M.values
nspA = null_space(A)
nspA.shape

for i in range(nspA,shape[1]):
  vnsp = Function(V, nspA[:V.dim(),i])
  pnsp = Function(Q, nspA[V.dim():,i])
  fig, ax = plt.subplots(2, 1) # grid of 2 rows 1 colums
  quiver(u_h, axes=ax[0])

  tripcolor(ph, axes=ax[1])
  ax[0].set_aspect('equal')
  ax[1].set_aspect('equal')

n = 5
mesh = UnitSquareMesh(n, n, diagonal='crossed') # it will be more obvious to see instability

V = VectorFunctionSpace(mesh, 'P', 1) # specify that we want a vector
Q = FunctionSpace(mesh, 'P', 1) # pressure is instead a scalar
# W = MixedFunctionSpace([V, Q])
W = V*Q # same thing, stacking variables in a single vector

W.sub(0) # zero for velocity or pressure, we can work only on the combined workspace
bcs = [DirichletBC(W.sub(0), Constant((1., 0.)), 4),          # part of the boundary interested, defying a constant velocity
       DirichletBC(W.sub(0), Constant((1., 0.)), (1,2,3))]

nullspace = MixedVectorSpaceBasis(
    W, [W.sub(0), VectorSpaceBasis(constant=True)]
) # i want a basis for space, the base need to be constant in a part, and whetever in the other part

f = Constant((0., 0.))

u, p = TrialFunctions(W) # combined function space, two types of trial functions
v, q = TestFunctions(W)

a = inner(grad(u), grad(v))*dx - p*div(v)*dx - q*div(u)*dx
delta = Constant(1.)
h = CellDiameter(mesh)
a_stab = - delta * h * h * dot(grad(p), grad(q)) *dx
L = dot(f, v)*dx # we need in this case a vector space

w = Function(W)
solve(a+a_stab==L, w, bcs, nullspace=nullspace,
      solver_parameters={'ksp_type':'gmres'})
uh, ph = w.subfunctions

fig, ax = plt.subplots(2, 1) # grid of 2 rows 1 colums
quiver(u_h, axes=ax[0])
tripcolor(ph, axes=ax[1])
ax[0].set_aspect('equal')
ax[1].set_aspect('equal')